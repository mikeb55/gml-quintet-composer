<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Quintet Composer v57 - BULLETPROOF</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .version {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
            font-size: 0.95em;
        }
        input, select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 10px 5px;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .button-group {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .output {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            max-height: 400px;
            overflow-y: auto;
        }
        .status {
            text-align: center;
            margin: 20px 0;
            font-size: 1.1em;
        }
        .status.generating { color: #f39c12; }
        .status.complete { color: #27ae60; }
        .status.error { color: #e74c3c; }
        .debug-info {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéº String Quintet Composer v57</h1>
        <div class="version">BULLETPROOF Version - Multiple Stops Working</div>
        
        <div class="controls">
            <div class="control-group">
                <label for="measures">Number of Measures:</label>
                <input type="number" id="measures" min="8" max="64" value="16">
            </div>
            
            <div class="control-group">
                <label for="tempo">Tempo (BPM):</label>
                <input type="number" id="tempo" min="40" max="200" value="120">
            </div>
            
            <div class="control-group">
                <label for="key">Key:</label>
                <select id="key">
                    <option value="C">C Major</option>
                    <option value="G">G Major</option>
                    <option value="D" selected>D Major</option>
                    <option value="A">A Major</option>
                    <option value="F">F Major</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="style">Compositional Style:</label>
                <select id="style">
                    <option value="classical">Classical</option>
                    <option value="romantic">Romantic</option>
                    <option value="modern">Modern</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="guitarStyle">Guitar Style:</label>
                <select id="guitarStyle">
                    <option value="arpeggiated">Arpeggiated</option>
                    <option value="strummed">Strummed Chords</option>
                    <option value="fingerstyle">Fingerstyle</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="multipleStops">Multiple Stops:</label>
                <select id="multipleStops">
                    <option value="0">None</option>
                    <option value="20">Few (20%)</option>
                    <option value="40" selected>Moderate (40%)</option>
                    <option value="60">Many (60%)</option>
                </select>
            </div>
        </div>
        
        <div class="button-group">
            <button onclick="generateComposition()">üéµ Generate Composition</button>
            <button onclick="playComposition()" id="playBtn" disabled>‚ñ∂Ô∏è Play Audio</button>
            <button onclick="stopPlayback()" id="stopBtn" disabled>‚èπÔ∏è Stop</button>
            <button onclick="exportMusicXML()" id="exportBtn" disabled>üìÑ Export MusicXML</button>
        </div>
        
        <div class="status" id="status"></div>
        <div class="output" id="output"></div>
        <div class="debug-info" id="debug" style="display: none;"></div>
    </div>

    <script>
        // Global variables
        let composition = null;
        let audioContext = null;
        let isPlaying = false;
        let currentSources = [];
        
        // Musical constants
        const KEYS = {
            'C': { tonic: 'C', notes: ['C', 'D', 'E', 'F', 'G', 'A', 'B'], sharps: 0 },
            'G': { tonic: 'G', notes: ['G', 'A', 'B', 'C', 'D', 'E', 'F#'], sharps: 1 },
            'D': { tonic: 'D', notes: ['D', 'E', 'F#', 'G', 'A', 'B', 'C#'], sharps: 2 },
            'A': { tonic: 'A', notes: ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#'], sharps: 3 },
            'F': { tonic: 'F', notes: ['F', 'G', 'A', 'Bb', 'C', 'D', 'E'], sharps: -1 }
        };
        
        // Instrument ranges
        const RANGES = {
            guitar: { min: 40, max: 67 },
            violin1: { min: 55, max: 103 },
            violin2: { min: 55, max: 96 },
            viola: { min: 48, max: 84 },
            cello: { min: 36, max: 76 }
        };
        
        // Note to MIDI conversion
        function noteToMidi(note, octave) {
            try {
                const noteMap = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 };
                let midi = 12 + (octave * 12) + noteMap[note[0]];
                if (note.includes('#')) midi++;
                if (note.includes('b')) midi--;
                return midi;
            } catch (e) {
                console.error('noteToMidi error:', e);
                return 60; // Default to middle C
            }
        }
        
        // MIDI to frequency
        function midiToFreq(midi) {
            return 440 * Math.pow(2, (midi - 69) / 12);
        }
        
        // Main generation function
        function generateComposition() {
            try {
                updateStatus('Generating composition...', 'generating');
                document.getElementById('debug').style.display = 'block';
                document.getElementById('debug').innerHTML = 'Starting generation...<br>';
                
                const measures = parseInt(document.getElementById('measures').value);
                const tempo = parseInt(document.getElementById('tempo').value);
                const key = document.getElementById('key').value;
                const style = document.getElementById('style').value;
                const guitarStyle = document.getElementById('guitarStyle').value;
                const multipleStops = parseInt(document.getElementById('multipleStops').value);
                
                composition = {
                    measures: measures,
                    tempo: tempo,
                    key: key,
                    style: style,
                    multipleStops: multipleStops,
                    timeSignature: { beats: 4, beatType: 4 },
                    parts: {
                        guitar: [],
                        violin1: [],
                        violin2: [],
                        viola: [],
                        cello: []
                    }
                };
                
                const progression = generateProgression(measures, key, style);
                addDebug('Generated ' + progression.length + ' chords');
                
                generateGuitarPart(progression, guitarStyle, key);
                generateViolin1Part(progression, key, multipleStops);
                generateViolin2Part(progression, key, multipleStops);
                generateViolaPart(progression, key, multipleStops);
                generateCelloPart(progression, key, multipleStops);
                
                displayComposition();
                updateStatus('Composition generated successfully!', 'complete');
                document.getElementById('playBtn').disabled = false;
                document.getElementById('exportBtn').disabled = false;
            } catch (e) {
                console.error('Generation error:', e);
                updateStatus('Error generating composition', 'error');
                addDebug('Error: ' + e.message);
            }
        }
        
        // Generate chord progression
        function generateProgression(measures, key, style) {
            const progressions = {
                classical: [1, 4, 5, 1, 1, 5, 5, 1],
                romantic: [1, 6, 4, 5, 1, 4, 2, 5],
                modern: [1, 2, 5, 1, 6, 4, 5, 1]
            };
            
            const pattern = progressions[style] || progressions.classical;
            const progression = [];
            
            for (let m = 0; m < measures; m++) {
                const chordNum = pattern[m % pattern.length];
                progression.push(generateChord(chordNum, key));
            }
            
            return progression;
        }
        
        // Generate chord
        function generateChord(degree, key) {
            const keyData = KEYS[key];
            const root = keyData.notes[degree - 1];
            const third = keyData.notes[(degree - 1 + 2) % 7];
            const fifth = keyData.notes[(degree - 1 + 4) % 7];
            
            return {
                degree: degree,
                root: root,
                notes: [root, third, fifth]
            };
        }
        
        // Generate guitar part
        function generateGuitarPart(progression, style, key) {
            const part = [];
            
            for (let m = 0; m < progression.length; m++) {
                const chord = progression[m];
                const measure = [];
                
                if (style === 'strummed') {
                    const voicing = [
                        noteToMidi(chord.root, 2),
                        noteToMidi(chord.notes[2], 2),
                        noteToMidi(chord.notes[0], 3),
                        noteToMidi(chord.notes[1], 3)
                    ].filter(note => note >= 40 && note <= 67);
                    
                    for (let beat = 0; beat < 4; beat++) {
                        measure.push({
                            notes: voicing,
                            duration: 1,
                            isChord: true
                        });
                    }
                } else if (style === 'fingerstyle') {
                    const bass = noteToMidi(chord.root, 2);
                    const treble = [
                        noteToMidi(chord.notes[0], 3),
                        noteToMidi(chord.notes[1], 3),
                        noteToMidi(chord.notes[2], 3)
                    ].filter(note => note >= 40 && note <= 67);
                    
                    for (let i = 0; i < 4; i++) {
                        measure.push({ notes: [bass], duration: 0.5, isChord: false });
                        measure.push({ notes: treble, duration: 0.5, isChord: true });
                    }
                } else {
                    // Arpeggiated
                    const arp = [
                        noteToMidi(chord.root, 2),
                        noteToMidi(chord.notes[2], 2),
                        noteToMidi(chord.notes[0], 3),
                        noteToMidi(chord.notes[1], 3)
                    ].filter(note => note >= 40 && note <= 67);
                    
                    for (let i = 0; i < 8; i++) {
                        measure.push({
                            notes: [arp[i % arp.length]],
                            duration: 0.5,
                            isChord: false
                        });
                    }
                }
                
                part.push(measure);
            }
            
            composition.parts.guitar = part;
        }
        
        // Generate Violin 1 part
        function generateViolin1Part(progression, key, stopsPercent) {
            const part = [];
            
            for (let m = 0; m < progression.length; m++) {
                const chord = progression[m];
                const measure = [];
                
                // Simple melody with occasional double stops
                const base = noteToMidi(chord.notes[0], 5);
                
                if (Math.random() * 100 < stopsPercent && m % 2 === 0) {
                    // Double stop on downbeat
                    measure.push({
                        notes: [base, base + 4],
                        duration: 2,
                        isMultipleStop: true
                    });
                    measure.push({
                        notes: [base + 2],
                        duration: 2,
                        isChord: false
                    });
                } else {
                    // Single notes
                    measure.push({ notes: [base], duration: 2, isChord: false });
                    measure.push({ notes: [base + 2], duration: 1, isChord: false });
                    measure.push({ notes: [base - 1], duration: 1, isChord: false });
                }
                
                part.push(measure);
            }
            
            composition.parts.violin1 = part;
        }
        
        // Generate Violin 2 part
        function generateViolin2Part(progression, key, stopsPercent) {
            const part = [];
            
            for (let m = 0; m < progression.length; m++) {
                const chord = progression[m];
                const measure = [];
                
                const base = noteToMidi(chord.notes[1], 4);
                
                if (Math.random() * 100 < stopsPercent / 2) {
                    // Occasional double stop
                    measure.push({
                        notes: [base, base + 3],
                        duration: 4,
                        isMultipleStop: true
                    });
                } else {
                    measure.push({ notes: [base], duration: 4, isChord: false });
                }
                
                part.push(measure);
            }
            
            composition.parts.violin2 = part;
        }
        
        // Generate Viola part
        function generateViolaPart(progression, key, stopsPercent) {
            const part = [];
            
            for (let m = 0; m < progression.length; m++) {
                const chord = progression[m];
                const measure = [];
                
                const base = noteToMidi(chord.notes[2], 3);
                
                if (Math.random() * 100 < stopsPercent / 2 && m % 4 === 0) {
                    // Double stop
                    measure.push({
                        notes: [base, base + 5],
                        duration: 2,
                        isMultipleStop: true
                    });
                    measure.push({ notes: [base + 2], duration: 2, isChord: false });
                } else {
                    measure.push({ notes: [base], duration: 2, isChord: false });
                    measure.push({ notes: [base + 2], duration: 2, isChord: false });
                }
                
                part.push(measure);
            }
            
            composition.parts.viola = part;
        }
        
        // Generate Cello part
        function generateCelloPart(progression, key, stopsPercent) {
            const part = [];
            
            for (let m = 0; m < progression.length; m++) {
                const chord = progression[m];
                const measure = [];
                
                const root = noteToMidi(chord.root, 2);
                
                if (Math.random() * 100 < stopsPercent / 3 && m % 8 === 0) {
                    // Powerful octave double stop
                    measure.push({
                        notes: [root, root + 12],
                        duration: 4,
                        isMultipleStop: true
                    });
                } else {
                    measure.push({ notes: [root], duration: 2, isChord: false });
                    measure.push({ notes: [root + 7], duration: 2, isChord: false });
                }
                
                part.push(measure);
            }
            
            composition.parts.cello = part;
        }
        
        // Display composition
        function displayComposition() {
            const output = document.getElementById('output');
            let html = '<h3>Composition Generated</h3>';
            html += '<p><strong>Key:</strong> ' + composition.key + '</p>';
            html += '<p><strong>Tempo:</strong> ' + composition.tempo + ' BPM</p>';
            html += '<p><strong>Measures:</strong> ' + composition.measures + '</p>';
            
            // Count multiple stops
            let stopCount = 0;
            ['violin1', 'violin2', 'viola', 'cello'].forEach(inst => {
                composition.parts[inst].forEach(measure => {
                    measure.forEach(event => {
                        if (event.isMultipleStop) stopCount++;
                    });
                });
            });
            
            html += '<p><strong>Multiple Stops:</strong> ' + stopCount + '</p>';
            output.innerHTML = html;
        }
        
        // Play composition
        function playComposition() {
            if (!composition) return;
            
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                stopPlayback();
                isPlaying = true;
                document.getElementById('playBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                const tempo = composition.tempo;
                const beatDuration = 60 / tempo;
                let currentTime = audioContext.currentTime;
                
                Object.keys(composition.parts).forEach(instrument => {
                    const part = composition.parts[instrument];
                    let measureTime = currentTime;
                    
                    part.forEach(measure => {
                        let beatTime = measureTime;
                        
                        measure.forEach(event => {
                            if (event.notes && event.notes.length > 0) {
                                event.notes.forEach(note => {
                                    playNote(note, beatTime, event.duration * beatDuration, instrument);
                                });
                            }
                            beatTime += event.duration * beatDuration;
                        });
                        
                        measureTime += 4 * beatDuration;
                    });
                });
                
                const totalDuration = composition.measures * 4 * beatDuration;
                setTimeout(() => {
                    if (isPlaying) {
                        stopPlayback();
                        updateStatus('Playback complete', 'complete');
                    }
                }, totalDuration * 1000);
                
                updateStatus('Playing...', 'generating');
            } catch (e) {
                console.error('Playback error:', e);
                updateStatus('Error during playback', 'error');
                stopPlayback();
            }
        }
        
        function playNote(midi, startTime, duration, instrument) {
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                const waveforms = {
                    guitar: 'triangle',
                    violin1: 'sawtooth',
                    violin2: 'sawtooth',
                    viola: 'sawtooth',
                    cello: 'sawtooth'
                };
                
                oscillator.type = waveforms[instrument] || 'sine';
                oscillator.frequency.value = midiToFreq(midi);
                
                const baseVolumes = {
                    guitar: 0.15,
                    violin1: 0.2,
                    violin2: 0.18,
                    viola: 0.18,
                    cello: 0.2
                };
                
                const volume = baseVolumes[instrument] || 0.2;
                
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.01);
                gainNode.gain.setValueAtTime(volume, startTime + duration - 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + duration);
                
                currentSources.push(oscillator);
            } catch (e) {
                console.error('playNote error:', e);
            }
        }
        
        function stopPlayback() {
            isPlaying = false;
            currentSources.forEach(source => {
                try { source.stop(); } catch(e) {}
            });
            currentSources = [];
            document.getElementById('playBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }
        
        // Export MusicXML
        function exportMusicXML() {
            if (!composition) return;
            
            try {
                const xml = generateMusicXML(composition);
                const blob = new Blob([xml], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'quintet_v57_' + Date.now() + '.musicxml';
                a.click();
                URL.revokeObjectURL(url);
                
                updateStatus('MusicXML exported!', 'complete');
            } catch (e) {
                console.error('Export error:', e);
                updateStatus('Error exporting MusicXML', 'error');
            }
        }
        
        function generateMusicXML(comp) {
            let xml = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n';
            xml += '<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.0 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">\n';
            xml += '<score-partwise version="3.0">\n';
            xml += '  <work><work-title>String Quintet v57</work-title></work>\n';
            xml += '  <part-list>\n';
            xml += '    <score-part id="P1"><part-name>Guitar</part-name></score-part>\n';
            xml += '    <score-part id="P2"><part-name>Violin I</part-name></score-part>\n';
            xml += '    <score-part id="P3"><part-name>Violin II</part-name></score-part>\n';
            xml += '    <score-part id="P4"><part-name>Viola</part-name></score-part>\n';
            xml += '    <score-part id="P5"><part-name>Cello</part-name></score-part>\n';
            xml += '  </part-list>\n';
            
            const partIds = ['P1', 'P2', 'P3', 'P4', 'P5'];
            const partNames = ['guitar', 'violin1', 'violin2', 'viola', 'cello'];
            const clefs = ['G', 'G', 'G', 'C', 'F'];
            const clefLines = [2, 2, 2, 3, 4];
            
            for (let p = 0; p < partIds.length; p++) {
                xml += '  <part id="' + partIds[p] + '">\n';
                const partData = comp.parts[partNames[p]];
                
                partData.forEach((measure, mIndex) => {
                    xml += '    <measure number="' + (mIndex + 1) + '">\n';
                    
                    if (mIndex === 0) {
                        xml += '      <attributes>\n';
                        xml += '        <divisions>256</divisions>\n';
                        xml += '        <key><fifths>' + (KEYS[comp.key].sharps || 0) + '</fifths></key>\n';
                        xml += '        <time><beats>4</beats><beat-type>4</beat-type></time>\n';
                        xml += '        <clef><sign>' + clefs[p] + '</sign><line>' + clefLines[p] + '</line></clef>\n';
                        if (p === 0) {
                            xml += '        <transpose><octave-change>-1</octave-change></transpose>\n';
                        }
                        xml += '      </attributes>\n';
                    }
                    
                    measure.forEach(event => {
                        if (event.notes && event.notes.length > 0) {
                            event.notes.forEach((note, idx) => {
                                const adjustedNote = (p === 0) ? note + 12 : note;
                                xml += createNoteXML(adjustedNote, event.duration * 256, idx > 0);
                            });
                        }
                    });
                    
                    xml += '    </measure>\n';
                });
                
                xml += '  </part>\n';
            }
            
            xml += '</score-partwise>\n';
            return xml;
        }
        
        function createNoteXML(midi, duration, isChordNote) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(midi / 12) - 1;
            const noteIndex = midi % 12;
            const noteName = noteNames[noteIndex];
            
            let xml = '      <note>\n';
            if (isChordNote) {
                xml += '        <chord/>\n';
            }
            xml += '        <pitch>\n';
            xml += '          <step>' + noteName.replace('#', '') + '</step>\n';
            if (noteName.includes('#')) {
                xml += '          <alter>1</alter>\n';
            }
            xml += '          <octave>' + octave + '</octave>\n';
            xml += '        </pitch>\n';
            xml += '        <duration>' + Math.floor(duration) + '</duration>\n';
            xml += '        <type>' + getDurationType(duration) + '</type>\n';
            xml += '      </note>\n';
            
            return xml;
        }
        
        function getDurationType(duration) {
            if (duration >= 1024) return 'whole';
            if (duration >= 512) return 'half';
            if (duration >= 256) return 'quarter';
            if (duration >= 128) return 'eighth';
            return 'sixteenth';
        }
        
        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
        }
        
        function addDebug(message) {
            const debug = document.getElementById('debug');
            debug.innerHTML += message + '<br>';
            debug.scrollTop = debug.scrollHeight;
        }
        
        window.onload = function() {
            updateStatus('Ready to compose - v57 BULLETPROOF', 'complete');
        };
    </script>
</body>
</html>