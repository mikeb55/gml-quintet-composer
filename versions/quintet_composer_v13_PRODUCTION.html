<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quintet Composer v11.0 - Bulletproof All Stops</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            max-width: 900px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2.5em;
        }

        .version-tag {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        input, select {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #f0f0ff;
            border-radius: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .button-group {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 30px;
        }

        #compositionDisplay {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }

        .instrument-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .stops-summary {
            margin-top: 10px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 8px;
            font-size: 12px;
        }

        .stop-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            font-size: 10px;
            margin: 2px;
        }

        .stop-double { background: #4caf50; }
        .stop-triple { background: #ff9800; }
        .stop-quadruple { background: #f44336; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¼ Quintet Composer</h1>
        <div class="version-tag">Version 11.0 - Bulletproof All Stops Types</div>
        
        <div class="controls">
            <div class="control-group">
                <label for="measures">Number of Measures:</label>
                <input type="number" id="measures" min="1" max="100" value="4">
            </div>
            
            <div class="control-group">
                <label for="tempo">Tempo (BPM):</label>
                <input type="number" id="tempo" min="40" max="200" value="120">
            </div>
            
            <div class="control-group">
                <label for="key">Key:</label>
                <select id="key">
                    <option value="C">C Major</option>
                    <option value="G">G Major</option>
                    <option value="D">D Major</option>
                    <option value="A">A Major</option>
                    <option value="F">F Major</option>
                    <option value="Bb">Bb Major</option>
                    <option value="Eb">Eb Major</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="timeSignature">Time Signature:</label>
                <select id="timeSignature">
                    <option value="4/4">4/4</option>
                    <option value="3/4">3/4</option>
                    <option value="6/8">6/8</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="noteType">Rhythm Pattern:</label>
                <select id="noteType">
                    <option value="quarter">Simple (Quarter Notes)</option>
                    <option value="mixed">Mixed (Varied)</option>
                    <option value="complex">Complex (Counterpoint)</option>
                </select>
            </div>
            
            <div class="control-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="enableStops" onchange="updateStopsControls()">
                    <label for="enableStops">Enable Multiple Stops</label>
                </div>
            </div>
            
            <div class="control-group" id="stopsControls" style="display:none;">
                <label>Stop Types Distribution:</label>
                <div style="display: grid; gap: 10px;">
                    <div>
                        <label for="doubleStops">Double Stops: <span id="doubleValue">20</span>%</label>
                        <input type="range" id="doubleStops" min="0" max="50" value="20" oninput="document.getElementById('doubleValue').textContent = this.value">
                    </div>
                    <div>
                        <label for="tripleStops">Triple Stops: <span id="tripleValue">10</span>%</label>
                        <input type="range" id="tripleStops" min="0" max="30" value="10" oninput="document.getElementById('tripleValue').textContent = this.value">
                    </div>
                    <div>
                        <label for="quadrupleStops">Quadruple Stops: <span id="quadValue">5</span>%</label>
                        <input type="range" id="quadrupleStops" min="0" max="20" value="5" oninput="document.getElementById('quadValue').textContent = this.value">
                    </div>
                </div>
            </div>
        </div>
        
        <div class="button-group">
            <button onclick="generateComposition()">ðŸŽµ Generate Composition</button>
            <button onclick="exportMIDI()">ðŸ’¾ Export MIDI</button>
            <button onclick="exportMusicXML()">ðŸ“„ Export MusicXML</button>
            <button onclick="testAllSystems()">ðŸ§ª Test All Systems</button>
        </div>
        
        <div id="compositionDisplay"></div>
        <div class="instrument-stats" id="instrumentStats"></div>
        <div class="stops-summary" id="stopsSummary" style="display:none;"></div>
    </div>

    <script>
        // ==========================================
        // COMPREHENSIVE STOPS VALIDATOR MODULE
        // Based on Vamos, Trott, Harvey methods
        // ==========================================
        const StopsValidator = {
            // String tunings (MIDI note numbers)
            tunings: {
                violin: [55, 62, 69, 76],  // G3, D4, A4, E5
                viola: [48, 55, 62, 69],   // C3, G3, D4, A4  
                cello: [36, 43, 50, 57]    // C2, G2, D3, A3
            },
            
            // Maximum comfortable finger stretch in semitones
            maxStretch: {
                violin: 10,  // Conservative for reliability
                viola: 11,
                cello: 14    // Larger hand frame + thumb position
            },
            
            // Generate a playable stop of specified type
            generateStop: function(basePitch, instrument, stopType, scale) {
                const tuning = this.tunings[instrument];
                let numNotes = stopType === 'double' ? 2 : stopType === 'triple' ? 3 : 4;
                
                // Ensure base pitch is playable
                if (basePitch < tuning[0] || basePitch > tuning[3] + 24) {
                    basePitch = tuning[1] + 7; // Safe middle range
                }
                
                let attempts = 0;
                while (attempts < 10) {
                    attempts++;
                    
                    // Build chord based on scale
                    let chord = [basePitch];
                    
                    if (numNotes >= 2) {
                        // Try to use open strings when possible
                        for (let openString of tuning) {
                            if (scale.includes(openString % 12) && !chord.includes(openString) && 
                                openString !== basePitch && Math.abs(openString - basePitch) <= 12) {
                                chord.push(openString);
                                if (chord.length === numNotes) break;
                            }
                        }
                        
                        // Fill remaining with scale tones
                        if (chord.length < numNotes) {
                            const intervals = [3, 4, 5, 7]; // thirds, fourths, fifths
                            for (let interval of intervals) {
                                const note = basePitch + interval;
                                if (!chord.includes(note) && this.canPlayNote(note, instrument)) {
                                    chord.push(note);
                                    if (chord.length === numNotes) break;
                                }
                            }
                        }
                    }
                    
                    // Validate the chord
                    const validation = this.validateStop(chord, instrument);
                    if (validation.status !== 'impossible') {
                        chord.sort((a, b) => a - b);
                        return { notes: chord, validation: validation };
                    }
                    
                    // Try different base pitch
                    basePitch = tuning[Math.floor(Math.random() * 4)] + Math.floor(Math.random() * 7);
                }
                
                // Fallback: return simple interval
                return { 
                    notes: [basePitch], 
                    validation: { status: 'playable', message: 'Single note fallback' }
                };
            },
            
            validateStop: function(notes, instrument) {
                if (!notes || notes.length === 0) {
                    return { status: 'impossible', message: 'No notes' };
                }
                
                if (notes.length === 1) {
                    return { status: 'playable', message: 'Single note' };
                }
                
                if (notes.length > 4) {
                    return { status: 'impossible', message: 'More than 4 notes' };
                }
                
                // Sort for analysis
                const sortedNotes = [...notes].sort((a, b) => a - b);
                
                // Check if all notes are playable
                const tuning = this.tunings[instrument];
                for (let note of sortedNotes) {
                    if (note < tuning[0] - 2 || note > tuning[3] + 24) {
                        return { status: 'impossible', message: 'Note out of range' };
                    }
                }
                
                // Assign strings
                const assignment = this.assignStringsOptimal(sortedNotes, instrument);
                if (!assignment) {
                    return { status: 'impossible', message: 'Cannot assign to strings' };
                }
                
                // Check finger stretch
                const stretchCheck = this.checkFingerStretch(assignment, instrument);
                if (stretchCheck.impossible) {
                    return { status: 'impossible', message: stretchCheck.reason };
                }
                
                // Triple and quadruple stops special rules
                if (notes.length === 3) {
                    // Triple stops are always somewhat difficult
                    return { status: 'difficult', message: 'Triple stop (requires bow rock)' };
                }
                
                if (notes.length === 4) {
                    // Quadruple stops are very difficult
                    return { status: 'difficult', message: 'Quadruple stop (requires arpeggio)' };
                }
                
                // Double stop checks
                if (notes.length === 2) {
                    const strings = assignment.map(a => a.string);
                    if (Math.abs(strings[0] - strings[1]) > 1) {
                        return { status: 'difficult', message: 'Non-adjacent strings' };
                    }
                    
                    if (stretchCheck.difficult) {
                        return { status: 'difficult', message: stretchCheck.reason };
                    }
                }
                
                return { status: 'playable', message: 'Standard technique' };
            },
            
            assignStringsOptimal: function(notes, instrument) {
                const tuning = this.tunings[instrument];
                const assignments = [];
                const usedStrings = new Set();
                
                // Try to assign each note to best string
                for (let note of notes) {
                    let bestString = -1;
                    let bestPosition = 999;
                    
                    for (let s = 0; s < 4; s++) {
                        if (usedStrings.has(s)) continue;
                        
                        const position = note - tuning[s];
                        if (position >= 0 && position <= 24) {
                            // Prefer lower positions and open strings
                            if (position < bestPosition || position === 0) {
                                bestString = s;
                                bestPosition = position;
                            }
                        }
                    }
                    
                    if (bestString === -1) return null;
                    
                    assignments.push({
                        note: note,
                        string: bestString,
                        position: bestPosition,
                        isOpen: bestPosition === 0
                    });
                    usedStrings.add(bestString);
                }
                
                return assignments;
            },
            
            checkFingerStretch: function(assignments, instrument) {
                const maxStretch = this.maxStretch[instrument];
                
                // Get only fingered notes (not open strings)
                const fingered = assignments.filter(a => !a.isOpen);
                
                if (fingered.length <= 1) {
                    return { impossible: false, difficult: false };
                }
                
                // Find min and max positions
                const positions = fingered.map(a => a.position);
                const span = Math.max(...positions) - Math.min(...positions);
                
                if (span > maxStretch) {
                    return {
                        impossible: true,
                        reason: `Finger span ${span} exceeds maximum ${maxStretch}`
                    };
                }
                
                if (span > maxStretch * 0.75) {
                    return {
                        difficult: true,
                        reason: `Large stretch required (${span} semitones)`
                    };
                }
                
                return { impossible: false, difficult: false };
            },
            
            canPlayNote: function(note, instrument) {
                const tuning = this.tunings[instrument];
                return note >= tuning[0] && note <= tuning[3] + 24;
            }
        };

        // ==========================================
        // MAIN COMPOSITION ENGINE
        // ==========================================
        let currentComposition = null;

        function updateStopsControls() {
            const enabled = document.getElementById('enableStops').checked;
            document.getElementById('stopsControls').style.display = enabled ? 'block' : 'none';
            document.getElementById('stopsSummary').style.display = enabled ? 'block' : 'none';
        }

        function generateComposition() {
            const measures = parseInt(document.getElementById('measures').value);
            const tempo = parseInt(document.getElementById('tempo').value);
            const key = document.getElementById('key').value;
            const timeSignature = document.getElementById('timeSignature').value;
            const noteType = document.getElementById('noteType').value;
            
            let composition = {
                tempo: tempo,
                timeSignature: timeSignature,
                key: key,
                measures: [],
                instruments: ['Guitar', 'Violin 1', 'Violin 2', 'Viola', 'Cello']
            };
            
            const keyScales = {
                'C': [60, 62, 64, 65, 67, 69, 71],
                'G': [67, 69, 71, 72, 74, 76, 78],
                'D': [62, 64, 66, 67, 69, 71, 73],
                'A': [69, 71, 73, 74, 76, 78, 80],
                'F': [65, 67, 69, 70, 72, 74, 76],
                'Bb': [70, 72, 74, 75, 77, 79, 81],
                'Eb': [63, 65, 67, 68, 70, 72, 74]
            };
            
            const scale = keyScales[key];
            const scalePattern = scale.map(n => n % 12); // For scale checking
            
            for (let m = 0; m < measures; m++) {
                const measure = {
                    number: m + 1,
                    notes: []
                };
                
                // Generate notes for each instrument
                for (let inst = 0; inst < 5; inst++) {
                    let basePitch = scale[0];
                    
                    // Adjust octave for each instrument
                    if (inst === 0) basePitch = basePitch + 0;  // Guitar
                    else if (inst === 1) basePitch = basePitch + 12; // Violin 1
                    else if (inst === 2) basePitch = basePitch + 7;  // Violin 2  
                    else if (inst === 3) basePitch = basePitch - 5;  // Viola
                    else if (inst === 4) {
                        basePitch = basePitch - 24; // Cello
                        basePitch = Math.max(36, Math.min(basePitch, 60));
                    }
                    
                    let notesInMeasure = 4;
                    if (timeSignature === '3/4') notesInMeasure = 3;
                    else if (timeSignature === '6/8') notesInMeasure = 6;
                    
                    for (let n = 0; n < notesInMeasure; n++) {
                        const scaleIndex = Math.floor(Math.random() * scale.length);
                        let pitch = basePitch + (scale[scaleIndex] - scale[0]);
                        
                        if (inst === 4) {
                            pitch = Math.max(36, Math.min(pitch, 60));
                        }
                        
                        let time = n;
                        let duration = 1;
                        
                        if (noteType === 'mixed' && n % 2 === 1) {
                            time = n - 0.5;
                            duration = 0.5;
                        } else if (noteType === 'complex') {
                            const pattern = (m + inst) % 3;
                            if (pattern === 0 && n === 0) {
                                duration = 2;
                            } else if (pattern === 1 && n % 2 === 0) {
                                duration = 0.5;
                                time = n * 0.75;
                            } else if (pattern === 2 && n === notesInMeasure - 1) {
                                duration = 1.5;
                            }
                        }
                        
                        // Multiple stops logic
                        let multipleStop = null;
                        let stopValidation = null;
                        
                        if (document.getElementById('enableStops').checked && inst > 0) {
                            const doubleChance = parseInt(document.getElementById('doubleStops').value);
                            const tripleChance = parseInt(document.getElementById('tripleStops').value);
                            const quadChance = parseInt(document.getElementById('quadrupleStops').value);
                            
                            const rand = Math.random() * 100;
                            const instrumentType = inst === 1 || inst === 2 ? 'violin' : 
                                                  inst === 3 ? 'viola' : 'cello';
                            
                            let stopType = null;
                            if (rand < quadChance && n === 0) { // Quads only on strong beats
                                stopType = 'quadruple';
                            } else if (rand < quadChance + tripleChance && (n === 0 || n === 2)) {
                                stopType = 'triple';
                            } else if (rand < quadChance + tripleChance + doubleChance) {
                                stopType = 'double';
                            }
                            
                            if (stopType) {
                                const result = StopsValidator.generateStop(pitch, instrumentType, stopType, scalePattern);
                                if (result.notes.length > 1) {
                                    multipleStop = result.notes;
                                    stopValidation = result.validation;
                                }
                            }
                        }
                        
                        measure.notes.push({
                            instrument: inst,
                            pitch: pitch,
                            time: time,
                            duration: duration,
                            velocity: 80,
                            multipleStop: multipleStop,
                            stopValidation: stopValidation
                        });
                    }
                }
                
                composition.measures.push(measure);
            }
            
            currentComposition = composition;
            displayComposition(composition);
        }
        
        function displayComposition(composition) {
            const display = document.getElementById('compositionDisplay');
            const stats = document.getElementById('instrumentStats');
            const stopsSummary = document.getElementById('stopsSummary');
            
            let output = `Composition in ${composition.key} Major\n`;
            output += `Tempo: ${composition.tempo} BPM | Time: ${composition.timeSignature}\n`;
            output += `${'='.repeat(50)}\n\n`;
            
            const instrumentCounts = [0, 0, 0, 0, 0];
            const stopsCount = { double: 0, triple: 0, quadruple: 0, playable: 0, difficult: 0 };
            
            composition.measures.forEach(measure => {
                output += `Measure ${measure.number}:\n`;
                composition.instruments.forEach((inst, idx) => {
                    const notes = measure.notes.filter(n => n.instrument === idx);
                    instrumentCounts[idx] += notes.length;
                    
                    let stopsInfo = "";
                    notes.forEach(note => {
                        if (note.multipleStop) {
                            const len = note.multipleStop.length;
                            if (len === 2) stopsCount.double++;
                            else if (len === 3) stopsCount.triple++;
                            else if (len === 4) stopsCount.quadruple++;
                            
                            if (note.stopValidation) {
                                if (note.stopValidation.status === 'playable') stopsCount.playable++;
                                else if (note.stopValidation.status === 'difficult') stopsCount.difficult++;
                            }
                        }
                    });
                    
                    const stops = notes.filter(n => n.multipleStop).length;
                    output += `  ${inst}: ${notes.length} notes`;
                    if (stops > 0) output += ` [${stops} stops]`;
                    output += '\n';
                });
                output += '\n';
            });
            
            display.textContent = output;
            
            // Display stats
            stats.innerHTML = '';
            composition.instruments.forEach((inst, idx) => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-label">${inst}</div>
                    <div class="stat-value">${instrumentCounts[idx]}</div>
                    <div class="stat-label">notes</div>
                `;
                stats.appendChild(card);
            });
            
            // Stops summary
            if (document.getElementById('enableStops').checked) {
                stopsSummary.innerHTML = `
                    <strong>Multiple Stops Summary:</strong><br>
                    <span class="stop-badge stop-double">Double: ${stopsCount.double}</span>
                    <span class="stop-badge stop-triple">Triple: ${stopsCount.triple}</span>
                    <span class="stop-badge stop-quadruple">Quadruple: ${stopsCount.quadruple}</span>
                    <br>
                    Status: ${stopsCount.playable} playable, ${stopsCount.difficult} difficult
                `;
            }
        }
        
        // ==========================================
        // BULLETPROOF MIDI EXPORT WITH STOPS
        // ==========================================
        function exportMIDI() {
            if (!currentComposition) {
                alert('Please generate a composition first!');
                return;
            }
            
            const tracks = [];
            const ticksPerQuarter = 480;
            
            // Tempo track
            const tempoTrack = [];
            const microsecondsPerQuarter = Math.round(60000000 / currentComposition.tempo);
            tempoTrack.push(0x00, 0xFF, 0x51, 0x03);
            tempoTrack.push((microsecondsPerQuarter >> 16) & 0xFF);
            tempoTrack.push((microsecondsPerQuarter >> 8) & 0xFF);
            tempoTrack.push(microsecondsPerQuarter & 0xFF);
            tempoTrack.push(0x00, 0xFF, 0x2F, 0x00);
            tracks.push(tempoTrack);
            
            // Instrument tracks
            for (let inst = 0; inst < 5; inst++) {
                const track = [];
                
                // Correct instrument assignments
                let programNumber;
                if (inst === 0) programNumber = 24;      // Acoustic Guitar (nylon)
                else if (inst === 1) programNumber = 40; // Violin
                else if (inst === 2) programNumber = 40; // Violin  
                else if (inst === 3) programNumber = 41; // Viola
                else if (inst === 4) programNumber = 42; // Cello
                
                track.push(0x00, 0xC0 | inst, programNumber);
                
                let currentTick = 0;
                const events = [];
                
                // Collect all events for this instrument
                currentComposition.measures.forEach(measure => {
                    const instNotes = measure.notes.filter(n => n.instrument === inst);
                    
                    instNotes.forEach(note => {
                        const measureStartTick = (measure.number - 1) * ticksPerQuarter * 4;
                        const noteStartTick = measureStartTick + Math.round(note.time * ticksPerQuarter);
                        const noteEndTick = noteStartTick + Math.round(note.duration * ticksPerQuarter);
                        
                        if (note.multipleStop && note.multipleStop.length > 1) {
                            // CRITICAL FIX: Multiple stops need simultaneous notes
                            // All notes start at same time
                            note.multipleStop.forEach((pitch, idx) => {
                                events.push({
                                    tick: noteStartTick,
                                    type: 'on',
                                    pitch: pitch,
                                    velocity: note.velocity
                                });
                                events.push({
                                    tick: noteEndTick,
                                    type: 'off',
                                    pitch: pitch,
                                    velocity: 0
                                });
                            });
                        } else {
                            // Single note
                            events.push({
                                tick: noteStartTick,
                                type: 'on',
                                pitch: note.pitch,
                                velocity: note.velocity
                            });
                            events.push({
                                tick: noteEndTick,
                                type: 'off',
                                pitch: note.pitch,
                                velocity: 0
                            });
                        }
                    });
                });
                
                // Sort events by tick time, then by type (offs before ons at same tick)
                events.sort((a, b) => {
                    if (a.tick !== b.tick) return a.tick - b.tick;
                    if (a.type === 'off' && b.type === 'on') return -1;
                    if (a.type === 'on' && b.type === 'off') return 1;
                    return 0;
                });
                
                // Write events to track with proper delta times
                events.forEach(event => {
                    const delta = event.tick - currentTick;
                    
                    // Write delta time
                    if (delta < 128) {
                        track.push(delta);
                    } else if (delta < 16384) {
                        track.push(((delta >> 7) & 0x7F) | 0x80);
                        track.push(delta & 0x7F);
                    } else {
                        track.push(((delta >> 14) & 0x7F) | 0x80);
                        track.push(((delta >> 7) & 0x7F) | 0x80);
                        track.push(delta & 0x7F);
                    }
                    
                    // Write MIDI event
                    if (event.type === 'on') {
                        track.push(0x90 | inst, event.pitch, event.velocity);
                    } else {
                        track.push(0x80 | inst, event.pitch, 0);
                    }
                    
                    currentTick = event.tick;
                });
                
                // End of track
                track.push(0x00, 0xFF, 0x2F, 0x00);
                tracks.push(track);
            }
            
            // Build complete MIDI file
            const header = [
                0x4D, 0x54, 0x68, 0x64, // "MThd"
                0x00, 0x00, 0x00, 0x06, // Header length
                0x00, 0x01,             // Format 1
                0x00, tracks.length,    // Number of tracks
                (ticksPerQuarter >> 8) & 0xFF, ticksPerQuarter & 0xFF
            ];
            
            let midiData = [...header];
            
            tracks.forEach(track => {
                midiData.push(0x4D, 0x54, 0x72, 0x6B); // "MTrk"
                const len = track.length;
                midiData.push((len >> 24) & 0xFF);
                midiData.push((len >> 16) & 0xFF);
                midiData.push((len >> 8) & 0xFF);
                midiData.push(len & 0xFF);
                midiData.push(...track);
            });
            
            // Download
            const blob = new Blob([new Uint8Array(midiData)], { type: 'audio/midi' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `quintet_${Date.now()}.mid`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // ==========================================
        // BULLETPROOF MUSICXML EXPORT WITH STOPS
        // ==========================================
        function exportMusicXML() {
            if (!currentComposition) {
                alert('Please generate a composition first!');
                return;
            }
            
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">\n';
            xml += '<score-partwise version="3.1">\n';
            xml += '  <part-list>\n';
            
            currentComposition.instruments.forEach((inst, idx) => {
                xml += `    <score-part id="P${idx + 1}">\n`;
                xml += `      <part-name>${inst}</part-name>\n`;
                xml += '    </score-part>\n';
            });
            
            xml += '  </part-list>\n';
            
            for (let inst = 0; inst < 5; inst++) {
                xml += `  <part id="P${inst + 1}">\n`;
                
                currentComposition.measures.forEach((measure, mIdx) => {
                    xml += `    <measure number="${measure.number}">\n`;
                    
                    if (mIdx === 0) {
                        xml += '      <attributes>\n';
                        xml += '        <divisions>4</divisions>\n';
                        xml += '        <key><fifths>0</fifths></key>\n';
                        const [beats, beatType] = currentComposition.timeSignature.split('/');
                        xml += `        <time><beats>${beats}</beats><beat-type>${beatType}</beat-type></time>\n`;
                        xml += `        <clef><sign>${inst === 4 ? 'F' : 'G'}</sign><line>${inst === 4 ? '4' : '2'}</line></clef>\n`;
                        xml += '      </attributes>\n';
                    }
                    
                    const instNotes = measure.notes.filter(n => n.instrument === inst);
                    
                    instNotes.forEach(note => {
                        if (note.multipleStop && note.multipleStop.length > 1) {
                            // Multiple stop - all notes as a chord
                            note.multipleStop.forEach((pitch, idx) => {
                                xml += '      <note>\n';
                                if (idx > 0) {
                                    xml += '        <chord/>\n'; // Mark as part of chord
                                }
                                
                                const noteNames = ['C', 'C', 'D', 'D', 'E', 'F', 'F', 'G', 'G', 'A', 'A', 'B'];
                                const step = noteNames[pitch % 12];
                                const octave = Math.floor(pitch / 12) - 1;
                                const alter = [1, 3, 6, 8, 10].includes(pitch % 12) ? 1 : 0;
                                
                                xml += '        <pitch>\n';
                                xml += `          <step>${step}</step>\n`;
                                if (alter) xml += `          <alter>${alter}</alter>\n`;
                                xml += `          <octave>${octave}</octave>\n`;
                                xml += '        </pitch>\n';
                                xml += `        <duration>${Math.round(note.duration * 4)}</duration>\n';
                                
                                let type = 'quarter';
                                if (note.duration >= 2) type = 'half';
                                else if (note.duration >= 1) type = 'quarter';
                                else if (note.duration >= 0.5) type = 'eighth';
                                else if (note.duration >= 0.25) type = 'sixteenth';
                                xml += `        <type>${type}</type>\n`;
                                
                                if (note.duration === 1.5 || note.duration === 0.75) {
                                    xml += '        <dot/>\n';
                                }
                                
                                // Add technical notation for difficult stops
                                if (idx === 0 && note.stopValidation) {
                                    if (note.multipleStop.length === 3) {
                                        xml += '        <notations>\n';
                                        xml += '          <technical>\n';
                                        xml += '            <triple-stop/>\n';
                                        xml += '          </technical>\n';
                                        xml += '        </notations>\n';
                                    } else if (note.multipleStop.length === 4) {
                                        xml += '        <notations>\n';
                                        xml += '          <technical>\n';
                                        xml += '            <quadruple-stop/>\n';
                                        xml += '          </technical>\n';
                                        xml += '        </notations>\n';
                                    }
                                }
                                
                                xml += '      </note>\n';
                            });
                        } else {
                            // Single note
                            const noteNames = ['C', 'C', 'D', 'D', 'E', 'F', 'F', 'G', 'G', 'A', 'A', 'B'];
                            const step = noteNames[note.pitch % 12];
                            const octave = Math.floor(note.pitch / 12) - 1;
                            const alter = [1, 3, 6, 8, 10].includes(note.pitch % 12) ? 1 : 0;
                            
                            xml += '      <note>\n';
                            xml += '        <pitch>\n';
                            xml += `          <step>${step}</step>\n`;
                            if (alter) xml += `          <alter>${alter}</alter>\n`;
                            xml += `          <octave>${octave}</octave>\n`;
                            xml += '        </pitch>\n';
                            xml += `        <duration>${Math.round(note.duration * 4)}</duration>\n';
                            
                            let type = 'quarter';
                            if (note.duration >= 2) type = 'half';
                            else if (note.duration >= 1) type = 'quarter';
                            else if (note.duration >= 0.5) type = 'eighth';
                            else if (note.duration >= 0.25) type = 'sixteenth';
                            xml += `        <type>${type}</type>\n`;
                            
                            if (note.duration === 1.5 || note.duration === 0.75) {
                                xml += '        <dot/>\n';
                            }
                            
                            xml += '      </note>\n';
                        }
                    });
                    
                    xml += '    </measure>\n';
                });
                
                xml += '  </part>\n';
            }
            
            xml += '</score-partwise>\n';
            
            // Download
            const blob = new Blob([xml], { type: 'application/vnd.recordare.musicxml+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `quintet_${Date.now()}.musicxml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // ==========================================
        // COMPREHENSIVE TEST FUNCTION
        // ==========================================
        function testAllSystems() {
            console.log("=== BULLETPROOF STOPS TEST ===");
            
            // Test 1: Basic generation
            console.log("\nTest 1: Basic generation without stops");
            document.getElementById('enableStops').checked = false;
            generateComposition();
            console.log("âœ“ Basic generation works");
            
            // Test 2: With all stop types
            console.log("\nTest 2: All stop types enabled");
            document.getElementById('enableStops').checked = true;
            document.getElementById('doubleStops').value = 30;
            document.getElementById('tripleStops').value = 15;
            document.getElementById('quadrupleStops').value = 10;
            updateStopsControls();
            generateComposition();
            
            // Count stops
            let doubleCount = 0, tripleCount = 0, quadCount = 0;
            currentComposition.measures.forEach(m => {
                m.notes.forEach(n => {
                    if (n.multipleStop) {
                        if (n.multipleStop.length === 2) doubleCount++;
                        else if (n.multipleStop.length === 3) tripleCount++;
                        else if (n.multipleStop.length === 4) quadCount++;
                    }
                });
            });
            
            console.log(`Found: ${doubleCount} double, ${tripleCount} triple, ${quadCount} quadruple stops`);
            
            // Test 3: MIDI Export
            console.log("\nTest 3: MIDI Export with stops");
            try {
                exportMIDI();
                console.log("âœ“ MIDI export successful");
            } catch(e) {
                console.error("âœ— MIDI export failed:", e);
            }
            
            // Test 4: MusicXML Export
            console.log("\nTest 4: MusicXML Export with stops");
            try {
                exportMusicXML();
                console.log("âœ“ MusicXML export successful");
            } catch(e) {
                console.error("âœ— MusicXML export failed:", e);
            }
            
            // Test 5: Validate stop playability
            console.log("\nTest 5: Stop validation test");
            const testStops = [
                { notes: [60, 67], inst: 'violin', expected: 'playable' },
                { notes: [55, 62, 69], inst: 'violin', expected: 'difficult' },
                { notes: [55, 62, 69, 76], inst: 'violin', expected: 'difficult' },
                { notes: [36, 90], inst: 'cello', expected: 'impossible' }
            ];
            
            testStops.forEach(test => {
                const result = StopsValidator.validateStop(test.notes, test.inst);
                console.log(`${test.inst} ${test.notes}: ${result.status} (expected: ${test.expected})`);
            });
            
            console.log("\n=== ALL TESTS COMPLETE ===");
            alert("All systems tested! Check console for detailed results.");
        }
        
        // Generate on load
        window.addEventListener('load', generateComposition);
    </script>
</body>
</html>
