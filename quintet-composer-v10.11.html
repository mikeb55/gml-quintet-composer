<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quintet Composer v10.11 - Real Composer Patterns</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            color: white;
            text-align: center;
        }
        
        .version-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .main-controls {
            padding: 30px;
            background: white;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 14px;
        }
        
        input, select, textarea {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            transition: all 0.3s ease;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .midi-import-zone {
            grid-column: span 2;
            border: 3px dashed #667eea;
            padding: 40px;
            text-align: center;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .midi-import-zone:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .midi-import-zone.dragover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
            transform: scale(1.02);
        }
        
        #midiFileInput {
            display: none;
        }
        
        .import-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .theme-input-group {
            grid-column: span 3;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
        }
        
        .theme-input {
            width: 100%;
            font-family: monospace;
            min-height: 60px;
        }
        
        .composer-grid {
            padding: 30px;
            background: #f8f9fa;
        }
        
        .composer-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .composer-card {
            padding: 20px;
            background: white;
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .composer-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .composer-card.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
        }
        
        .composer-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }
        
        .form-buttons {
            padding: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .form-button {
            padding: 12px 30px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .form-button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .form-button.secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .form-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .sections-container {
            padding: 30px;
            background: white;
        }
        
        .section {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .section-header {
            background: #f8f9fa;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        
        .section-header:hover {
            background: #e9ecef;
        }
        
        .section-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
        }
        
        .section-badge {
            display: inline-block;
            padding: 3px 10px;
            background: #667eea;
            color: white;
            border-radius: 12px;
            font-size: 11px;
            margin-left: 10px;
        }
        
        .section-form-badge {
            background: #28a745;
        }
        
        .section-controls {
            padding: 20px;
            background: white;
        }
        
        .section-controls.collapsed {
            display: none;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .instrument-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .instrument-header {
            font-weight: 600;
            margin-bottom: 10px;
            color: #495057;
        }
        
        .instrument-settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }
        
        .mini-composer-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .mini-composer-card {
            padding: 10px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }
        
        .mini-composer-card:hover {
            background: #f8f9fa;
        }
        
        .mini-composer-card.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
        }
        
        .status-message {
            padding: 15px;
            margin: 20px;
            border-radius: 10px;
            text-align: center;
            font-weight: 500;
        }
        
        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .toggle-arrow {
            transition: transform 0.3s ease;
        }
        
        .toggle-arrow.collapsed {
            transform: rotate(-90deg);
        }
        
        .composer-description {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎼 Quintet Composer</h1>
            <p>Advanced String Quintet Composition with Real Composer Patterns</p>
            <div class="version-badge">Version 10.11 - Each Composer Generates Unique Music</div>
        </div>
        
        <div class="main-controls">
            <div class="control-group">
                <label>Title</label>
                <input type="text" id="title" placeholder="My Quintet" value="String Quintet in C">
            </div>
            <div class="control-group">
                <label>Composer Name</label>
                <input type="text" id="composerName" placeholder="Your Name" value="GML Composer">
            </div>
            <div class="control-group">
                <label>Tempo (BPM)</label>
                <input type="number" id="tempo" min="40" max="200" value="120">
            </div>
            <div class="control-group">
                <label>Complexity</label>
                <select id="complexity">
                    <option value="simple">Simple</option>
                    <option value="moderate" selected>Moderate</option>
                    <option value="complex">Complex</option>
                </select>
            </div>
            
            <div class="midi-import-zone" id="midiDropZone" onclick="document.getElementById('midiFileInput').click()">
                <input type="file" id="midiFileInput" accept=".mid,.midi" style="display: none;">
                <div class="import-icon">📁</div>
                <div><strong>Drop MIDI file here or click to browse</strong></div>
                <div id="midiStatus" style="margin-top: 10px; color: #667eea;"></div>
            </div>
            
            <div class="theme-input-group">
                <label>Main Theme (MIDI note numbers, comma-separated)</label>
                <textarea id="themeInput" class="theme-input" placeholder="60, 64, 67, 72, 71, 67, 64, 60">60, 64, 67, 72, 71, 67, 64, 60</textarea>
                <div id="themePreview" style="margin-top: 10px; font-family: monospace; color: #667eea;"></div>
            </div>
        </div>
        
        <div class="composer-grid">
            <h3 style="margin-bottom: 20px;">Choose Default Composer Style</h3>
            <div class="composer-cards" id="composerCards">
                <div class="composer-card" data-composer="bach">
                    <div class="composer-icon">🎹</div>
                    <div><strong>Bach</strong></div>
                    <div style="font-size: 12px; color: #666;">Fugal • Contrapuntal</div>
                    <div class="composer-description">16th note runs, sequences</div>
                </div>
                <div class="composer-card selected" data-composer="mozart">
                    <div class="composer-icon">🎼</div>
                    <div><strong>Mozart</strong></div>
                    <div style="font-size: 12px; color: #666;">Classical • Elegant</div>
                    <div class="composer-description">Alberti bass, periodic phrases</div>
                </div>
                <div class="composer-card" data-composer="beethoven">
                    <div class="composer-icon">🎵</div>
                    <div><strong>Beethoven</strong></div>
                    <div style="font-size: 12px; color: #666;">Dramatic • Powerful</div>
                    <div class="composer-description">Fate motif, sforzando</div>
                </div>
                <div class="composer-card" data-composer="brahms">
                    <div class="composer-icon">🎻</div>
                    <div><strong>Brahms</strong></div>
                    <div style="font-size: 12px; color: #666;">Romantic • Dense</div>
                    <div class="composer-description">3 against 2, rich harmonies</div>
                </div>
                <div class="composer-card" data-composer="ravel">
                    <div class="composer-icon">🌊</div>
                    <div><strong>Ravel</strong></div>
                    <div style="font-size: 12px; color: #666;">Impressionist • Colorful</div>
                    <div class="composer-description">Bolero rhythm, modal colors</div>
                </div>
                <div class="composer-card" data-composer="glass">
                    <div class="composer-icon">🔄</div>
                    <div><strong>Glass</strong></div>
                    <div style="font-size: 12px; color: #666;">Minimalist • Repetitive</div>
                    <div class="composer-description">Additive patterns, phasing</div>
                </div>
            </div>
        </div>
        
        <div class="form-buttons">
            <button class="form-button secondary" onclick="addSection('exposition')">+ Exposition</button>
            <button class="form-button secondary" onclick="addSection('development')">+ Development</button>
            <button class="form-button secondary" onclick="addSection('recapitulation')">+ Recapitulation</button>
            <button class="form-button secondary" onclick="addSection('coda')">+ Coda</button>
            <button class="form-button secondary" onclick="addSection('custom')">+ Custom Section</button>
        </div>
        
        <div class="sections-container" id="sectionsContainer"></div>
        
        <div id="statusMessage"></div>
        
        <div class="form-buttons">
            <button class="form-button primary" onclick="generateComposition()">Generate Composition</button>
            <button class="form-button secondary" onclick="exportMusicXML()" id="exportBtn" style="display:none;">Export MusicXML</button>
        </div>
    </div>
    
    <script>
        // Global variables
        let selectedComposer = 'mozart';
        let sections = [];
        let generatedXML = '';
        let importedTheme = null;
        let mainTheme = [60, 64, 67, 72, 71, 67, 64, 60]; // C major arpeggio
        let globalMeasureNumber = 1;
        
        // Musical data
        const scales = {
            'C': ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            'G': ['G', 'A', 'B', 'C', 'D', 'E', 'F#'],
            'D': ['D', 'E', 'F#', 'G', 'A', 'B', 'C#'],
            'F': ['F', 'G', 'A', 'Bb', 'C', 'D', 'E'],
            'Bb': ['Bb', 'C', 'D', 'Eb', 'F', 'G', 'A'],
            'A': ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#'],
            'Eb': ['Eb', 'F', 'G', 'Ab', 'Bb', 'C', 'D']
        };
        
        const chordProgressions = {
            'C': [['C', 'E', 'G'], ['F', 'A', 'C'], ['G', 'B', 'D'], ['A', 'C', 'E']],
            'G': [['G', 'B', 'D'], ['C', 'E', 'G'], ['D', 'F#', 'A'], ['E', 'G', 'B']],
            'D': [['D', 'F#', 'A'], ['G', 'B', 'D'], ['A', 'C#', 'E'], ['B', 'D', 'F#']],
            'F': [['F', 'A', 'C'], ['Bb', 'D', 'F'], ['C', 'E', 'G'], ['D', 'F', 'A']],
            'Bb': [['Bb', 'D', 'F'], ['Eb', 'G', 'Bb'], ['F', 'A', 'C'], ['G', 'Bb', 'D']],
            'A': [['A', 'C#', 'E'], ['D', 'F#', 'A'], ['E', 'G#', 'B'], ['F#', 'A', 'C#']],
            'Eb': [['Eb', 'G', 'Bb'], ['Ab', 'C', 'Eb'], ['Bb', 'D', 'F'], ['C', 'Eb', 'G']]
        };
        
        // Composer-specific rhythm patterns
        const composerPatterns = {
            bach: {
                melody: [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1], // Continuous 16th notes
                harmony: [2,2,2,2, 2,2,2,2], // Running 8ths
                bass: [4,4,4,4], // Walking bass quarters
                rhythmic: [2,1,1, 2,1,1, 2,2] // Baroque pattern
            },
            mozart: {
                melody: [4,2,2, 4,4, 2,2,2,2], // Classical periodic phrase
                harmony: [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1], // Alberti pattern
                bass: [4,4,4,4], // Simple bass
                rhythmic: [2,2,2,2, 4,4] // Classical accompaniment
            },
            beethoven: {
                melody: [2,2,2,8, 2], // Fate motif: short-short-short-long
                harmony: [4,4,4,4], // Strong quarters
                bass: [8,8], // Powerful half notes
                rhythmic: [1,1,1,1,4, 8] // Dramatic rhythm
            },
            brahms: {
                melody: [6,6,6,6,6,6], // 3 against 2 (triplets in 4/4)
                harmony: [4,2,2, 4,4], // Romantic rubato feel
                bass: [8,4,4], // Rich bass movement
                rhythmic: [3,3,3,3,4] // Complex polyrhythm
            },
            ravel: {
                melody: [3,3,3,3,2,2], // Bolero rhythm
                harmony: [16], // Sustained harmony
                bass: [8,8], // Pedal tones
                rhythmic: [3,3,3,3,2,2] // Distinctive Bolero
            },
            glass: {
                melody: [1,1,1, 1,1,1, 1,1, 1,1,1, 1,1,1, 1,1], // Additive pattern
                harmony: [2,2,2,2, 2,2,2,2], // Constant eighth notes
                bass: [16], // Drone
                rhythmic: [1,1,1,1,1, 1,1,1,1,1, 1] // 5+5+1 pattern
            }
        };
        
        // Composer-specific melodic shapes
        const melodicShapes = {
            bach: { // Sequential, imitative
                ascending: [0,1,2,3, 1,2,3,4, 2,3,4,5],
                descending: [7,6,5,4, 6,5,4,3, 5,4,3,2],
                arch: [0,1,2,3,4,3,2,1,0]
            },
            mozart: { // Elegant, balanced phrases
                ascending: [0,2,4,5, 7,5,4,2],
                descending: [7,5,3,1, 0,1,2,0],
                arch: [0,2,4,7, 6,4,2,0]
            },
            beethoven: { // Motivic, forceful
                ascending: [0,0,0,3, 0,0,0,4],
                descending: [7,7,7,4, 7,7,7,3],
                arch: [0,3,5,7, 7,7,4,0]
            },
            brahms: { // Rich, chromatic
                ascending: [0,1,3,2, 4,3,5,4],
                descending: [7,6,4,5, 3,4,2,0],
                arch: [0,2,3,5, 4,3,1,0]
            },
            ravel: { // Modal, impressionistic
                ascending: [0,2,3,5, 6,5,3,2],
                descending: [7,5,4,2, 1,2,4,5],
                arch: [0,3,5,6, 5,3,2,0]
            },
            glass: { // Repetitive, minimal variation
                ascending: [0,1,2, 0,1,2, 1,2,3, 1,2,3],
                descending: [3,2,1, 3,2,1, 2,1,0, 2,1,0],
                arch: [0,1,2,1, 0,1,2,1, 2,3,4,3]
            }
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            addSection('exposition'); // Start with exposition
            updateThemePreview();
        });
        
        function setupEventListeners() {
            // Composer selection
            document.querySelectorAll('.composer-card').forEach(card => {
                card.addEventListener('click', function() {
                    document.querySelectorAll('.composer-card').forEach(c => c.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedComposer = this.dataset.composer;
                });
            });
            
            // MIDI import
            const dropZone = document.getElementById('midiDropZone');
            const fileInput = document.getElementById('midiFileInput');
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleMidiFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleMidiFile(e.target.files[0]);
                }
            });
            
            // Theme input
            document.getElementById('themeInput').addEventListener('input', updateThemePreview);
        }
        
        function handleMidiFile(file) {
            if (!file.name.match(/\.(mid|midi)$/i)) {
                showStatus('Please select a valid MIDI file', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    parseMidiFile(new Uint8Array(e.target.result));
                    document.getElementById('midiStatus').innerHTML = `✓ Loaded: ${file.name}`;
                    showStatus('MIDI file imported successfully!', 'success');
                } catch (error) {
                    console.error('MIDI parse error:', error);
                    document.getElementById('midiStatus').innerHTML = '✗ Error loading MIDI';
                    showStatus('Error parsing MIDI file', 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function parseMidiFile(data) {
            // Basic MIDI parser - extracts first melodic line
            const dataView = new DataView(data.buffer);
            
            // Check MThd header
            const headerChunk = String.fromCharCode(data[0], data[1], data[2], data[3]);
            if (headerChunk !== 'MThd') {
                throw new Error('Invalid MIDI file');
            }
            
            // Extract theme from MIDI data
            const extractedNotes = [];
            let offset = 14; // Skip header
            
            // Find MTrk chunk
            while (offset < data.length - 8) {
                const chunkType = String.fromCharCode(data[offset], data[offset+1], data[offset+2], data[offset+3]);
                const chunkLength = (data[offset+4] << 24) | (data[offset+5] << 16) | (data[offset+6] << 8) | data[offset+7];
                
                if (chunkType === 'MTrk') {
                    // Parse track for note events
                    let trackOffset = offset + 8;
                    const trackEnd = trackOffset + chunkLength;
                    
                    while (trackOffset < trackEnd && extractedNotes.length < 16) {
                        // Skip delta time (simplified)
                        while (trackOffset < trackEnd && (data[trackOffset] & 0x80)) {
                            trackOffset++;
                        }
                        trackOffset++;
                        
                        if (trackOffset >= trackEnd) break;
                        
                        const status = data[trackOffset];
                        
                        // Note on event (status 0x90-0x9F)
                        if ((status & 0xF0) === 0x90) {
                            trackOffset++;
                            if (trackOffset < trackEnd) {
                                const note = data[trackOffset];
                                const velocity = data[trackOffset + 1];
                                if (velocity > 0) { // Note on with velocity
                                    extractedNotes.push(note);
                                }
                                trackOffset += 2;
                            }
                        } else {
                            trackOffset++;
                        }
                        
                        if (extractedNotes.length >= 8) break;
                    }
                }
                
                offset += 8 + chunkLength;
            }
            
            // Use extracted notes or default if not enough found
            if (extractedNotes.length >= 4) {
                mainTheme = extractedNotes.slice(0, 8);
                while (mainTheme.length < 8) {
                    mainTheme.push(mainTheme[mainTheme.length % 4]); // Repeat pattern
                }
            } else {
                // Use default theme if extraction failed
                mainTheme = [60, 64, 67, 72, 71, 67, 64, 60];
            }
            
            // Update theme input
            document.getElementById('themeInput').value = mainTheme.join(', ');
            updateThemePreview();
            
            importedTheme = {
                notes: mainTheme.map(n => midiNoteToName(n)),
                octaves: mainTheme.map(n => Math.floor(n / 12) - 1),
                durations: Array(mainTheme.length).fill(4)
            };
        }
        
        function midiNoteToName(midiNumber) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            return noteNames[midiNumber % 12];
        }
        
        function updateThemePreview() {
            const input = document.getElementById('themeInput').value;
            const notes = input.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            
            if (notes.length > 0) {
                mainTheme = notes;
                const noteNames = notes.map(n => midiNoteToName(n) + Math.floor(n / 12 - 1));
                document.getElementById('themePreview').textContent = 'Preview: ' + noteNames.join(' - ');
            }
        }
        
        function addSection(type) {
            const sectionId = 'section_' + Date.now();
            const sectionNumber = sections.length + 1;
            
            // Set defaults based on section type
            let defaults = {
                'exposition': { key: 'C', bars: 8, transformation: 'original' },
                'development': { key: 'G', bars: 12, transformation: 'fragmented' },
                'recapitulation': { key: 'C', bars: 8, transformation: 'inverted' },
                'coda': { key: 'C', bars: 4, transformation: 'augmented' },
                'custom': { key: 'C', bars: 8, transformation: 'original' }
            };
            
            const section = {
                id: sectionId,
                type: type,
                number: sectionNumber,
                composer: selectedComposer,
                key: defaults[type].key,
                timeSignature: '4/4',
                bars: defaults[type].bars,
                transformation: defaults[type].transformation,
                instruments: {
                    guitar: { pattern: 'chords', polyrhythm: 'none', dynamics: 'mf' },
                    violin1: { pattern: 'melody', polyrhythm: 'none', dynamics: 'mf' },
                    violin2: { pattern: 'harmony', polyrhythm: 'none', dynamics: 'mp' },
                    viola: { pattern: 'rhythm', polyrhythm: 'none', dynamics: 'mp' },
                    cello: { pattern: 'bass', polyrhythm: 'none', dynamics: 'mf' }
                }
            };
            
            sections.push(section);
            renderSection(section);
        }
        
        function renderSection(section) {
            const container = document.getElementById('sectionsContainer');
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'section';
            sectionDiv.id = section.id;
            
            const formTypeLabel = section.type.charAt(0).toUpperCase() + section.type.slice(1);
            
            sectionDiv.innerHTML = `
                <div class="section-header" onclick="toggleSection('${section.id}')">
                    <div class="section-title">
                        <span class="toggle-arrow">▼</span>
                        <span>Section ${section.number}: ${formTypeLabel}</span>
                        <span class="section-badge section-form-badge">${formTypeLabel}</span>
                        <span class="section-badge">${section.composer}</span>
                    </div>
                    <button class="form-button secondary" style="padding: 5px 15px;" onclick="removeSection('${section.id}'); event.stopPropagation();">Remove</button>
                </div>
                <div class="section-controls" id="controls_${section.id}">
                    <div class="mini-composer-grid">
                        ${['bach', 'mozart', 'beethoven', 'brahms', 'ravel', 'glass'].map(c => `
                            <div class="mini-composer-card ${c === section.composer ? 'selected' : ''}" 
                                 onclick="updateSectionComposer('${section.id}', '${c}')">
                                ${c.charAt(0).toUpperCase() + c.slice(1)}
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="controls-grid">
                        <div class="control-group">
                            <label>Key</label>
                            <select onchange="updateSectionProperty('${section.id}', 'key', this.value)">
                                ${['C', 'G', 'D', 'F', 'Bb', 'A', 'Eb'].map(k => 
                                    `<option value="${k}" ${k === section.key ? 'selected' : ''}>${k} Major</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Time Signature</label>
                            <select onchange="updateSectionProperty('${section.id}', 'timeSignature', this.value)">
                                ${['4/4', '3/4', '5/4', '6/8', '7/8'].map(t => 
                                    `<option value="${t}" ${t === section.timeSignature ? 'selected' : ''}>${t}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Measures</label>
                            <input type="number" value="${section.bars}" min="1" max="32" 
                                   onchange="updateSectionProperty('${section.id}', 'bars', this.value)">
                        </div>
                        <div class="control-group">
                            <label>Theme Transformation</label>
                            <select onchange="updateSectionProperty('${section.id}', 'transformation', this.value)">
                                ${['original', 'fragmented', 'inverted', 'augmented', 'retrograde'].map(t => 
                                    `<option value="${t}" ${t === section.transformation ? 'selected' : ''}>${t}</option>`
                                ).join('')}
                            </select>
                        </div>
                    </div>
                    
                    ${Object.entries(section.instruments).map(([inst, settings]) => `
                        <div class="instrument-controls">
                            <div class="instrument-header">${getInstrumentDisplayName(inst)}</div>
                            <div class="instrument-settings">
                                <div class="control-group">
                                    <label>Pattern</label>
                                    <select onchange="updateInstrumentProperty('${section.id}', '${inst}', 'pattern', this.value)">
                                        ${getPatternOptions(inst).map(p => 
                                            `<option value="${p.value}" ${p.value === settings.pattern ? 'selected' : ''}>${p.label}</option>`
                                        ).join('')}
                                    </select>
                                </div>
                                <div class="control-group">
                                    <label>Polyrhythm</label>
                                    <select onchange="updateInstrumentProperty('${section.id}', '${inst}', 'polyrhythm', this.value)">
                                        <option value="none" ${settings.polyrhythm === 'none' ? 'selected' : ''}>None</option>
                                        <option value="3:2" ${settings.polyrhythm === '3:2' ? 'selected' : ''}>3:2</option>
                                        <option value="4:3" ${settings.polyrhythm === '4:3' ? 'selected' : ''}>4:3</option>
                                        <option value="5:4" ${settings.polyrhythm === '5:4' ? 'selected' : ''}>5:4</option>
                                        <option value="7:6" ${settings.polyrhythm === '7:6' ? 'selected' : ''}>7:6</option>
                                    </select>
                                </div>
                                <div class="control-group">
                                    <label>Dynamics</label>
                                    <select onchange="updateInstrumentProperty('${section.id}', '${inst}', 'dynamics', this.value)">
                                        ${['pp', 'p', 'mp', 'mf', 'f', 'ff'].map(d => 
                                            `<option value="${d}" ${d === settings.dynamics ? 'selected' : ''}>${d}</option>`
                                        ).join('')}
                                    </select>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            container.appendChild(sectionDiv);
        }
        
        function getInstrumentDisplayName(inst) {
            const names = {
                'guitar': '🎸 Guitar',
                'violin1': '🎻 Violin I',
                'violin2': '🎻 Violin II',
                'viola': '🎻 Viola',
                'cello': '🎻 Cello'
            };
            return names[inst] || inst;
        }
        
        function getPatternOptions(instrument) {
            const patterns = [
                { value: 'melody', label: 'Melody' },
                { value: 'harmony', label: 'Harmony' },
                { value: 'bass', label: 'Bass Line' },
                { value: 'rhythm', label: 'Rhythmic' },
                { value: 'chords', label: 'Chords' },
                { value: 'tremolo', label: 'Tremolo' },
                { value: 'pizzicato', label: 'Pizzicato' },
                { value: 'arpeggio', label: 'Arpeggio' },
                { value: 'pedal', label: 'Pedal Tone' },
                { value: 'theme', label: 'Use Theme' }
            ];
            return patterns;
        }
        
        function toggleSection(sectionId) {
            const controls = document.getElementById('controls_' + sectionId);
            const arrow = document.querySelector(`#${sectionId} .toggle-arrow`);
            
            controls.classList.toggle('collapsed');
            arrow.classList.toggle('collapsed');
        }
        
        function updateSectionComposer(sectionId, composer) {
            const section = sections.find(s => s.id === sectionId);
            if (section) {
                section.composer = composer;
                // Update UI
                document.querySelectorAll(`#${sectionId} .mini-composer-card`).forEach(card => {
                    card.classList.remove('selected');
                    if (card.textContent.toLowerCase().includes(composer)) {
                        card.classList.add('selected');
                    }
                });
                // Update badge
                document.querySelector(`#${sectionId} .section-badge:not(.section-form-badge)`).textContent = composer;
            }
        }
        
        function updateSectionProperty(sectionId, property, value) {
            const section = sections.find(s => s.id === sectionId);
            if (section) {
                section[property] = property === 'bars' ? parseInt(value) : value;
            }
        }
        
        function updateInstrumentProperty(sectionId, instrument, property, value) {
            const section = sections.find(s => s.id === sectionId);
            if (section && section.instruments[instrument]) {
                section.instruments[instrument][property] = value;
            }
        }
        
        function removeSection(sectionId) {
            sections = sections.filter(s => s.id !== sectionId);
            document.getElementById(sectionId).remove();
            // Renumber sections
            sections.forEach((s, i) => {
                s.number = i + 1;
            });
        }
        
        function transformTheme(theme, transformation) {
            const transformed = [...theme];
            
            switch(transformation) {
                case 'inverted':
                    // Invert intervals
                    const pivot = transformed[0];
                    return transformed.map(note => pivot - (note - pivot));
                
                case 'retrograde':
                    // Reverse the theme
                    return transformed.reverse();
                
                case 'augmented':
                    // Double note durations (handled in rhythm generation)
                    return transformed;
                
                case 'fragmented':
                    // Take first 4 notes and develop
                    return transformed.slice(0, 4).concat(transformed.slice(0, 4));
                
                default:
                    return transformed;
            }
        }
        
        function generateComposition() {
            if (sections.length === 0) {
                showStatus('Please add at least one section', 'error');
                return;
            }
            
            showStatus('Generating composition with unique composer patterns...', 'success');
            globalMeasureNumber = 1; // Reset measure counter
            
            // Generate MusicXML
            generatedXML = generateMusicXML();
            
            // Show export button
            document.getElementById('exportBtn').style.display = 'inline-block';
            
            showStatus('Composition generated successfully!', 'success');
        }
        
        function generateMusicXML() {
            const title = document.getElementById('title').value;
            const composer = document.getElementById('composerName').value;
            const tempo = document.getElementById('tempo').value;
            
            let xml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <work>
    <work-title>${title}</work-title>
  </work>
  <identification>
    <creator type="composer">${composer}</creator>
    <encoding>
      <software>Quintet Composer v10.11</software>
      <encoding-date>${new Date().toISOString().split('T')[0]}</encoding-date>
    </encoding>
  </identification>
  <part-list>
    <score-part id="P1"><part-name>Guitar</part-name></score-part>
    <score-part id="P2"><part-name>Violin I</part-name></score-part>
    <score-part id="P3"><part-name>Violin II</part-name></score-part>
    <score-part id="P4"><part-name>Viola</part-name></score-part>
    <score-part id="P5"><part-name>Cello</part-name></score-part>
  </part-list>`;
            
            const instruments = ['guitar', 'violin1', 'violin2', 'viola', 'cello'];
            const partIds = ['P1', 'P2', 'P3', 'P4', 'P5'];
            
            // Generate parts
            instruments.forEach((inst, idx) => {
                xml += `\n  <part id="${partIds[idx]}">`;
                
                let measureNumber = 1;
                
                sections.forEach((section, sectionIdx) => {
                    const theme = transformTheme(mainTheme, section.transformation);
                    const scale = scales[section.key];
                    const chords = chordProgressions[section.key];
                    
                    for (let m = 0; m < section.bars; m++) {
                        // Add attributes for first measure of section
                        if (m === 0) {
                            xml += `\n    <measure number="${measureNumber}">
      <print>
        <measure-numbering>system</measure-numbering>
      </print>`;
                            xml += `\n      <attributes>
        <divisions>16</divisions>
        <key><fifths>${getKeyFifths(section.key)}</fifths></key>
        <time><beats>${section.timeSignature.split('/')[0]}</beats><beat-type>${section.timeSignature.split('/')[1]}</beat-type></time>`;
                            
                            if (measureNumber === 1) {
                                xml += `\n        <clef><sign>${inst === 'cello' ? 'F' : inst === 'viola' ? 'C' : 'G'}</sign><line>${inst === 'cello' ? '4' : inst === 'viola' ? '3' : '2'}</line></clef>`;
                                
                                // Add tempo marking on first measure
                                if (idx === 0) { // Only on first part
                                    xml += `\n      </attributes>
      <direction placement="above">
        <direction-type>
          <metronome>
            <beat-unit>quarter</beat-unit>
            <per-minute>${tempo}</per-minute>
          </metronome>
        </direction-type>
      </direction>`;
                                } else {
                                    xml += `\n      </attributes>`;
                                }
                            } else {
                                xml += `\n      </attributes>`;
                            }
                            
                            // Add rehearsal mark for first instrument only
                            if (idx === 0 && m === 0) {
                                xml += `\n      <direction placement="above">
        <direction-type>
          <rehearsal>${String.fromCharCode(65 + sectionIdx)} (${section.type} - ${section.composer})</rehearsal>
        </direction-type>
      </direction>`;
                            }
                        } else {
                            xml += `\n    <measure number="${measureNumber}">`;
                        }
                        
                        // Generate notes based on composer-specific patterns
                        xml += generateComposerSpecificNotes(inst, section, theme, scale, chords[m % chords.length], m);
                        
                        xml += '\n    </measure>';
                        measureNumber++;
                    }
                });
                
                xml += '\n  </part>';
            });
            
            xml += '\n</score-partwise>';
            return xml;
        }
        
        function generateComposerSpecificNotes(instrument, section, theme, scale, chord, measureIdx) {
            const settings = section.instruments[instrument];
            const composer = section.composer;
            const pattern = settings.pattern;
            let notesXML = '';
            
            // Get the appropriate rhythm pattern for this composer and pattern type
            const rhythmPattern = getComposerRhythm(composer, pattern);
            const melodicShape = getMelodicShape(composer, pattern, measureIdx);
            
            // Get appropriate octave for instrument
            const octaveMap = {
                'guitar': 3,
                'violin1': 4,
                'violin2': 4,
                'viola': 3,
                'cello': 2
            };
            const baseOctave = octaveMap[instrument];
            
            // Special handling for different instrument/pattern combinations
            if (instrument === 'guitar' && pattern === 'chords') {
                // All composers use chords for guitar, but with different rhythms
                const chordRhythm = composerPatterns[composer].rhythmic || [4,4,4,4];
                let rhythmIndex = 0;
                let beatCount = 0;
                const beatsPerMeasure = parseInt(section.timeSignature.split('/')[0]);
                
                while (beatCount < beatsPerMeasure * 4) { // 4 divisions per beat
                    const duration = chordRhythm[rhythmIndex % chordRhythm.length];
                    const chordNotes = getChordNotes(chord, section.key, instrument);
                    
                    chordNotes.forEach((note, idx) => {
                        notesXML += createNote(
                            note.pitch,
                            note.octave,
                            note.alter,
                            duration,
                            idx > 0
                        );
                    });
                    
                    beatCount += duration;
                    rhythmIndex++;
                }
            } else if (pattern === 'melody' && instrument === 'violin1') {
                // Generate composer-specific melodic lines
                const melodyNotes = generateMelody(composer, scale, theme, baseOctave, measureIdx);
                notesXML += melodyNotes;
            } else if (pattern === 'harmony') {
                // Generate harmony based on composer style
                const harmonyNotes = generateHarmony(composer, chord, scale, baseOctave, measureIdx);
                notesXML += harmonyNotes;
            } else if (pattern === 'bass' && instrument === 'cello') {
                // Generate bass line specific to each composer
                const bassNotes = generateBassLine(composer, chord, scale, baseOctave, measureIdx);
                notesXML += bassNotes;
            } else {
                // Default pattern generation with composer-specific rhythms
                const defaultNotes = generateDefaultPattern(
                    composer, pattern, scale, chord, baseOctave, 
                    section.timeSignature, measureIdx
                );
                notesXML += defaultNotes;
            }
            
            // Add dynamics on first measure of section
            if (settings.dynamics && measureIdx === 0) {
                notesXML = `\n      <direction placement="below">
        <direction-type>
          <dynamics><${settings.dynamics}/></dynamics>
        </direction-type>
      </direction>` + notesXML;
            }
            
            return notesXML;
        }
        
        function generateMelody(composer, scale, theme, octave, measureIdx) {
            let xml = '';
            const shape = melodicShapes[composer].ascending;
            const rhythm = composerPatterns[composer].melody;
            
            let rhythmIndex = 0;
            let noteIndex = 0;
            
            for (let i = 0; i < rhythm.length; i++) {
                const duration = rhythm[i];
                const scaleIndex = shape[noteIndex % shape.length] % scale.length;
                const note = scale[scaleIndex];
                const cleanNote = note.replace('#', '').replace('b', '');
                const alter = note.includes('#') ? 1 : note.includes('b') ? -1 : 0;
                
                xml += createNote(cleanNote, octave, alter, duration, false);
                noteIndex++;
            }
            
            return xml;
        }
        
        function generateHarmony(composer, chord, scale, octave, measureIdx) {
            let xml = '';
            const rhythm = composerPatterns[composer].harmony;
            
            if (composer === 'mozart') {
                // Mozart: Alberti bass pattern (low-high-middle-high)
                const albertiPattern = [0, 2, 1, 2]; // Indices into chord
                for (let i = 0; i < rhythm.length; i++) {
                    const chordNote = chord[albertiPattern[i % 4]];
                    const cleanNote = chordNote.replace('#', '').replace('b', '');
                    const alter = chordNote.includes('#') ? 1 : chordNote.includes('b') ? -1 : 0;
                    xml += createNote(cleanNote, octave, alter, rhythm[i], false);
                }
            } else {
                // Other composers: different harmonic patterns
                for (let i = 0; i < rhythm.length; i++) {
                    const chordNote = chord[i % chord.length];
                    const cleanNote = chordNote.replace('#', '').replace('b', '');
                    const alter = chordNote.includes('#') ? 1 : chordNote.includes('b') ? -1 : 0;
                    xml += createNote(cleanNote, octave, alter, rhythm[i], false);
                }
            }
            
            return xml;
        }
        
        function generateBassLine(composer, chord, scale, octave, measureIdx) {
            let xml = '';
            const rhythm = composerPatterns[composer].bass;
            
            if (composer === 'bach') {
                // Bach: Walking bass
                const walkingPattern = [0, 2, 4, 2]; // Root, third, fifth, third
                for (let i = 0; i < rhythm.length; i++) {
                    const scaleIndex = walkingPattern[i % 4];
                    const note = scale[scaleIndex];
                    const cleanNote = note.replace('#', '').replace('b', '');
                    const alter = note.includes('#') ? 1 : note.includes('b') ? -1 : 0;
                    xml += createNote(cleanNote, octave, alter, rhythm[i], false);
                }
            } else if (composer === 'beethoven') {
                // Beethoven: Powerful octaves
                for (let i = 0; i < rhythm.length; i++) {
                    const chordNote = chord[0]; // Root
                    const cleanNote = chordNote.replace('#', '').replace('b', '');
                    const alter = chordNote.includes('#') ? 1 : chordNote.includes('b') ? -1 : 0;
                    const useOctave = i % 2 === 0 ? octave : octave + 1;
                    xml += createNote(cleanNote, useOctave, alter, rhythm[i], false);
                }
            } else {
                // Default bass pattern
                for (let i = 0; i < rhythm.length; i++) {
                    const noteToUse = i % 2 === 0 ? chord[0] : scale[4]; // Root and fifth
                    const cleanNote = noteToUse.replace('#', '').replace('b', '');
                    const alter = noteToUse.includes('#') ? 1 : noteToUse.includes('b') ? -1 : 0;
                    xml += createNote(cleanNote, octave, alter, rhythm[i], false);
                }
            }
            
            return xml;
        }
        
        function generateDefaultPattern(composer, pattern, scale, chord, octave, timeSignature, measureIdx) {
            let xml = '';
            const beatsPerMeasure = parseInt(timeSignature.split('/')[0]);
            const rhythm = composerPatterns[composer].rhythmic || [4,4,4,4];
            
            let beatCount = 0;
            let noteIndex = 0;
            
            while (beatCount < beatsPerMeasure * 4) {
                const duration = rhythm[noteIndex % rhythm.length];
                const note = scale[noteIndex % scale.length];
                const cleanNote = note.replace('#', '').replace('b', '');
                const alter = note.includes('#') ? 1 : note.includes('b') ? -1 : 0;
                
                xml += createNote(cleanNote, octave, alter, duration, false);
                beatCount += duration;
                noteIndex++;
            }
            
            return xml;
        }
        
        function getComposerRhythm(composer, pattern) {
            const patterns = composerPatterns[composer];
            if (pattern === 'melody') return patterns.melody;
            if (pattern === 'harmony') return patterns.harmony;
            if (pattern === 'bass') return patterns.bass;
            return patterns.rhythmic;
        }
        
        function getMelodicShape(composer, pattern, measureIdx) {
            const shapes = melodicShapes[composer];
            const shapeTypes = ['ascending', 'descending', 'arch'];
            const shapeType = shapeTypes[measureIdx % 3];
            return shapes[shapeType];
        }
        
        function getChordNotes(chord, key, instrument) {
            const baseOctave = instrument === 'guitar' ? 3 :
                              instrument === 'cello' ? 2 :
                              instrument === 'viola' ? 3 : 4;
            
            return chord.map((note, idx) => {
                let alter = 0;
                if (note.includes('#')) alter = 1;
                if (note.includes('b')) alter = -1;
                
                const cleanNote = note.replace('#', '').replace('b', '');
                
                return {
                    pitch: cleanNote,
                    octave: baseOctave + (idx > 1 ? 1 : 0),
                    alter: alter
                };
            });
        }
        
        function createNote(pitch, octave, alter, duration, isChord, articulation = null) {
            // Clean the pitch
            const cleanPitch = pitch.charAt(0);
            
            // Map duration to note type
            const durationTypes = {
                1: '16th',
                2: 'eighth',
                3: 'eighth', // Dotted eighth (handled separately)
                4: 'quarter',
                6: 'quarter', // Dotted quarter
                8: 'half',
                12: 'half', // Dotted half
                16: 'whole'
            };
            
            const noteType = durationTypes[duration] || 'quarter';
            const isDotted = duration === 3 || duration === 6 || duration === 12;
            
            let xml = '\n      <note>';
            if (isChord) {
                xml += '\n        <chord/>';
            }
            xml += `\n        <pitch>
          <step>${cleanPitch}</step>`;
            
            if (alter !== 0) {
                xml += `\n          <alter>${alter}</alter>`;
            }
            
            xml += `\n          <octave>${octave}</octave>
        </pitch>
        <duration>${duration}</duration>
        <type>${noteType}</type>`;
            
            if (isDotted) {
                xml += '\n        <dot/>';
            }
            
            if (articulation) {
                xml += '\n        <notations>';
                if (articulation === 'staccato') {
                    xml += '\n          <articulations>\n            <staccato/>\n          </articulations>';
                } else if (articulation === 'accent') {
                    xml += '\n          <articulations>\n            <accent/>\n          </articulations>';
                }
                xml += '\n        </notations>';
            }
            
            xml += '\n      </note>';
            
            return xml;
        }
        
        function getKeyFifths(key) {
            const fifths = {
                'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5,
                'F': -1, 'Bb': -2, 'Eb': -3, 'Ab': -4, 'Db': -5, 'Gb': -6
            };
            return fifths[key] || 0;
        }
        
        function exportMusicXML() {
            if (!generatedXML) {
                showStatus('Please generate a composition first', 'error');
                return;
            }
            
            const blob = new Blob([generatedXML], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const date = new Date().toISOString().split('T')[0];
            a.download = `quintet_v10.11_${date}.musicxml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus('MusicXML exported successfully!', 'success');
        }
        
        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            
            setTimeout(() => {
                statusDiv.className = '';
                statusDiv.textContent = '';
            }, 3000);
        }
    </script>
</body>
</html>