<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quintet Composer v12.14 - Varied Generation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #2d3748;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .section-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .section-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 15px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
        }

        .section-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
        }

        .sections-container {
            margin: 30px 0;
        }

        .section-card {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .section-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .section-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2d3748;
        }

        .section-controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #2d3748;
        }

        .section-settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .setting-group {
            background: rgba(255, 255, 255, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }

        .setting-group h4 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #4a5568;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }


        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
        }

        .button-group button {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .button-group button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .button-group button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        #status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: 600;
        }

        .status-success {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
        }

        .status-error {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
        }

        .status-info {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
        }

        .collapsible {
            cursor: pointer;
            user-select: none;
        }

        .collapsible:after {
            content: ' ▼';
            font-size: 0.8em;
            transition: transform 0.3s ease;
        }

        .collapsible.collapsed:after {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎼 Quintet Composer v12.14 - Varied Generation</h1>
        
        <!-- Section Type Buttons -->
        <div class="section-types">
            <button class="section-btn" onclick="addSection('Exposition')">📖 Exposition</button>
            <button class="section-btn" onclick="addSection('Development')">🔄 Development</button>
            <button class="section-btn" onclick="addSection('Recapitulation')">🔄 Recapitulation</button>
            <button class="section-btn" onclick="addSection('Coda')">🎯 Coda</button>
            <button class="section-btn" onclick="addSection('Bridge')">🌉 Bridge</button>
            <button class="section-btn" onclick="addSection('Variation')">🎨 Variation</button>
        </div>
        
        <!-- Sections Container -->
        <div id="sectionsContainer"></div>
        
        <!-- Generate/Export Buttons -->
        <div class="button-group">
            <button onclick="generateScore()">🎼 Generate Score</button>
            <button onclick="exportMusicXML()" class="secondary" id="exportBtn" disabled style="background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);">💾 Export MusicXML</button>
            <button onclick="resetAll()" style="background: linear-gradient(135deg, #fc8181 0%, #f56565 100%);">🔄 Reset All</button>
        </div>
        
        <div id="status"></div>
    </div>
    
    <script>
        // Global variables
        let currentScore = null;
        let sections = [];
        let sectionCounter = 0;
        
        // Composer profiles
        const COMPOSERS = {
            bach: { name: 'Bach', style: 'Fugal' },
            mozart: { name: 'Mozart', style: 'Classical' },
            beethoven: { name: 'Beethoven', style: 'Dramatic' },
            brahms: { name: 'Brahms', style: 'Romantic' },
            ravel: { name: 'Ravel', style: 'Impressionist' },
            chopin: { name: 'Chopin', style: 'Romantic' },
            debussy: { name: 'Debussy', style: 'Impressionist' },
            jazz: { name: 'Jazz', style: 'Modern' },
            glass: { name: 'Glass', style: 'Minimalist' },
            bartok: { name: 'Bartók', style: 'Modern' },
            shostakovich: { name: 'Shostakovich', style: 'Modern' },
            stravinsky: { name: 'Stravinsky', style: 'Modern' },
            mahler: { name: 'Mahler', style: 'Romantic' },
            tchaikovsky: { name: 'Tchaikovsky', style: 'Romantic' },
            vivaldi: { name: 'Vivaldi', style: 'Baroque' },
            handel: { name: 'Handel', style: 'Baroque' }
        };
        
        // Section templates
        const SECTION_TEMPLATES = {
            'Exposition': { measures: 8, key: 'C', composer: 'mozart' },
            'Development': { measures: 12, key: 'G', composer: 'beethoven' },
            'Recapitulation': { measures: 8, key: 'C', composer: 'mozart' },
            'Coda': { measures: 4, key: 'C', composer: 'beethoven' },
            'Bridge': { measures: 6, key: 'F', composer: 'chopin' },
            'Variation': { measures: 8, key: 'C', composer: 'brahms' }
        };
        
        // Add section
        function addSection(type) {
            const template = SECTION_TEMPLATES[type];
            const section = {
                id: `section_${++sectionCounter}`,
                name: `${type} ${sectionCounter}`,
                templateName: type,
                measures: template.measures,
                key: template.key,
                composer: template.composer,
                instruments: {
                    guitar: { pattern: 'chords', dynamics: 'mf' },
                    violin1: { pattern: 'melody', dynamics: 'f' },
                    violin2: { pattern: 'harmony', dynamics: 'mf' },
                    viola: { pattern: 'arpeggios', dynamics: 'p' },
                    cello: { pattern: 'bassline', dynamics: 'mf' }
                }
            };
            
            sections.push(section);
            renderSections();
            showStatus(`Added ${type} section`, 'success');
        }
        
        // Render sections
        function renderSections() {
            const container = document.getElementById('sectionsContainer');
            container.innerHTML = '';
            
            sections.forEach((section, index) => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'section-card';
                sectionDiv.innerHTML = `
                    <div class="section-header">
                        <h3 class="section-title">${section.name}</h3>
                        <div class="section-controls">
                            <button class="btn btn-secondary" onclick="toggleSection(${index})">⚙️ Settings</button>
                            <button class="btn btn-danger" onclick="removeSection(${index})">🗑️ Remove</button>
                        </div>
                    </div>
                    <div class="section-settings" id="settings_${index}">
                        <div class="setting-group">
                            <h4>🎼 Basic Settings</h4>
                            <div class="form-group">
                                <label>Section Name:</label>
                                <input type="text" value="${section.name}" onchange="updateSection(${index}, 'name', this.value)">
                            </div>
                            <div class="form-group">
                                <label>Measures:</label>
                                <input type="number" value="${section.measures}" min="1" max="32" onchange="updateSection(${index}, 'measures', parseInt(this.value))">
                            </div>
                            <div class="form-group">
                                <label>Key Signature:</label>
                                <select onchange="updateSection(${index}, 'key', this.value)">
                                    <option value="C" ${section.key === 'C' ? 'selected' : ''}>C Major</option>
                                    <option value="G" ${section.key === 'G' ? 'selected' : ''}>G Major</option>
                                    <option value="D" ${section.key === 'D' ? 'selected' : ''}>D Major</option>
                                    <option value="A" ${section.key === 'A' ? 'selected' : ''}>A Major</option>
                                    <option value="F" ${section.key === 'F' ? 'selected' : ''}>F Major</option>
                                    <option value="Bb" ${section.key === 'Bb' ? 'selected' : ''}>Bb Major</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="setting-group">
                            <h4>🎭 Composer Style</h4>
                            <div class="form-group">
                                <label>Composer:</label>
                                <select onchange="updateSection(${index}, 'composer', this.value)">
                                    ${Object.entries(COMPOSERS).map(([key, composer]) => `
                                        <option value="${key}" ${section.composer === key ? 'selected' : ''}>${composer.name} - ${composer.style}</option>
                                    `).join('')}
                                </select>
                            </div>
                        </div>
                        
                        <div class="setting-group">
                            <h4>🎵 Instrument Patterns</h4>
                            <div class="form-group">
                                <label>Guitar:</label>
                                <select onchange="updateInstrument(${index}, 'guitar', 'pattern', this.value)">
                                    <option value="chords" ${section.instruments.guitar.pattern === 'chords' ? 'selected' : ''}>Chords</option>
                                    <option value="arpeggios" ${section.instruments.guitar.pattern === 'arpeggios' ? 'selected' : ''}>Arpeggios</option>
                                    <option value="melody" ${section.instruments.guitar.pattern === 'melody' ? 'selected' : ''}>Melody</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Violin I:</label>
                                <select onchange="updateInstrument(${index}, 'violin1', 'pattern', this.value)">
                                    <option value="melody" ${section.instruments.violin1.pattern === 'melody' ? 'selected' : ''}>Melody</option>
                                    <option value="harmony" ${section.instruments.violin1.pattern === 'harmony' ? 'selected' : ''}>Harmony</option>
                                    <option value="counterpoint" ${section.instruments.violin1.pattern === 'counterpoint' ? 'selected' : ''}>Counterpoint</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Violin II:</label>
                                <select onchange="updateInstrument(${index}, 'violin2', 'pattern', this.value)">
                                    <option value="harmony" ${section.instruments.violin2.pattern === 'harmony' ? 'selected' : ''}>Harmony</option>
                                    <option value="melody" ${section.instruments.violin2.pattern === 'melody' ? 'selected' : ''}>Melody</option>
                                    <option value="counterpoint" ${section.instruments.violin2.pattern === 'counterpoint' ? 'selected' : ''}>Counterpoint</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Viola:</label>
                                <select onchange="updateInstrument(${index}, 'viola', 'pattern', this.value)">
                                    <option value="arpeggios" ${section.instruments.viola.pattern === 'arpeggios' ? 'selected' : ''}>Arpeggios</option>
                                    <option value="harmony" ${section.instruments.viola.pattern === 'harmony' ? 'selected' : ''}>Harmony</option>
                                    <option value="melody" ${section.instruments.viola.pattern === 'melody' ? 'selected' : ''}>Melody</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Cello:</label>
                                <select onchange="updateInstrument(${index}, 'cello', 'pattern', this.value)">
                                    <option value="bassline" ${section.instruments.cello.pattern === 'bassline' ? 'selected' : ''}>Bassline</option>
                                    <option value="melody" ${section.instruments.cello.pattern === 'melody' ? 'selected' : ''}>Melody</option>
                                    <option value="harmony" ${section.instruments.cello.pattern === 'harmony' ? 'selected' : ''}>Harmony</option>
                                </select>
                            </div>
                        </div>
                    </div>
                `;
                container.appendChild(sectionDiv);
            });
        }
        
        // Toggle section settings
        function toggleSection(index) {
            const settings = document.getElementById(`settings_${index}`);
            settings.style.display = settings.style.display === 'none' ? 'block' : 'none';
        }
        
        // Remove section
        function removeSection(index) {
            sections.splice(index, 1);
            renderSections();
            showStatus('Section removed', 'info');
        }
        
        // Update section
        function updateSection(index, property, value) {
            sections[index][property] = value;
            showStatus(`Updated ${property}`, 'success');
        }
        
        
        // Update instrument
        function updateInstrument(index, instrument, property, value) {
            sections[index].instruments[instrument][property] = value;
            showStatus(`Updated ${instrument} ${property}`, 'success');
        }
        
        // Generate score
        function generateScore() {
            try {
                showStatus('Generating score...', 'info');
                
                // Check if we have sections
                if (sections.length === 0) {
                    showStatus('Please add at least one section first!', 'error');
                    return;
                }
                
                // Build structure summary
                const structure = sections.map(s => `${s.name}:${s.templateName}`).join(' → ');
                
                // Create score object with all the necessary data
                currentScore = {
                    sections: sections,
                    generated: new Date().toISOString(),
                    structure: structure,
                    totalMeasures: sections.reduce((total, section) => total + section.measures, 0)
                };
                
                // Enable export button
                document.getElementById('exportBtn').disabled = false;
                
                showStatus(`Score generated successfully! Structure: ${structure}`, 'success');
                
            } catch (error) {
                console.error('Generation error:', error);
                showStatus(`Error: ${error.message}`, 'error');
            }
        }
        
        // Export MusicXML
        function exportMusicXML() {
            if (!currentScore) {
                showStatus('No score to export!', 'error');
                return;
            }
            
            try {
                showStatus('Generating MusicXML...', 'info');
                
                // Generate proper MusicXML with varied content based on settings
                let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
                xml += '<score-partwise version="3.1">\n';
                xml += '  <work>\n';
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                const title = `Quintet Composition ${timestamp}`;
                xml += `    <work-title>${title}</work-title>\n`;
                xml += '  </work>\n';
                xml += '  <part-list>\n';
                xml += '    <score-part id="P1"><part-name>Guitar</part-name></score-part>\n';
                xml += '    <score-part id="P2"><part-name>Violin I</part-name></score-part>\n';
                xml += '    <score-part id="P3"><part-name>Violin II</part-name></score-part>\n';
                xml += '    <score-part id="P4"><part-name>Viola</part-name></score-part>\n';
                xml += '    <score-part id="P5"><part-name>Cello</part-name></score-part>\n';
                xml += '  </part-list>\n';
                
                // Generate parts with varied content
                const instruments = ['guitar', 'violin1', 'violin2', 'viola', 'cello'];
                instruments.forEach((inst, i) => {
                    xml += `  <part id="P${i+1}">\n`;
                    
                    let measureNumber = 1;
                    sections.forEach((section, s) => {
                        // Get section settings
                        const composer = section.composer;
                        const key = section.key;
                        const pattern = section.instruments[inst].pattern;
                        const dynamics = section.instruments[inst].dynamics;
                        
                        for (let m = 1; m <= section.measures; m++) {
                            xml += `    <measure number="${measureNumber}">\n`;
                            
                            if (measureNumber === 1) {
                                // Add key signature based on section key
                                const keyFifths = getKeyFifths(key);
                                xml += `      <attributes><divisions>4</divisions><key><fifths>${keyFifths}</fifths></key><time><beats>4</beats><beat-type>4</beat-type></time></attributes>\n`;
                            }
                            
                            // Add rehearsal marker for first measure of each section
                            if (m === 1) {
                                xml += `      <direction placement="above">\n`;
                                xml += `        <direction-type>\n`;
                                xml += `          <rehearsal>${section.name} (${COMPOSERS[composer].name})</rehearsal>\n`;
                                xml += `        </direction-type>\n`;
                                xml += `      </direction>\n`;
                            }
                            
                            // Generate varied notes based on composer style and instrument pattern
                            const notes = generateNotesForInstrument(inst, pattern, composer, key, m, section.measures);
                            xml += notes;
                            
                            xml += '    </measure>\n';
                            measureNumber++;
                        }
                    });
                    xml += '  </part>\n';
                });
                
                xml += '</score-partwise>';
                
                // Download
                const blob = new Blob([xml], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quintet-${Date.now()}.musicxml`;
                a.click();
                URL.revokeObjectURL(url);
                
                showStatus('MusicXML exported successfully!', 'success');
                
            } catch (error) {
                console.error('Export error:', error);
                showStatus(`Export error: ${error.message}`, 'error');
            }
        }
        
        // Helper function to get key signature fifths
        function getKeyFifths(key) {
            const keyMap = {
                'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5, 'F#': 6,
                'F': -1, 'Bb': -2, 'Eb': -3, 'Ab': -4, 'Db': -5, 'Gb': -6
            };
            return keyMap[key] || 0;
        }
        
        // Generate varied notes based on instrument, pattern, composer, and key
        function generateNotesForInstrument(inst, pattern, composer, key, measure, totalMeasures) {
            let xml = '';
            
            // Get composer-specific characteristics
            const composerStyle = getComposerStyle(composer);
            const keyNotes = getKeyNotes(key);
            
            // Generate content based on composer style for ALL instruments
            if (composer === 'bach') {
                // Bach: Complex contrapuntal style
                if (inst === 'guitar' && pattern === 'chords') {
                    xml += generateBachGuitarChord(keyNotes, measure);
                } else if ((inst === 'violin1' || inst === 'violin2') && pattern === 'melody') {
                    xml += generateBachMelody(keyNotes, measure, inst);
                } else if (inst === 'cello' && pattern === 'bassline') {
                    xml += generateBachBassline(keyNotes, measure);
                } else if (inst === 'viola' && pattern === 'arpeggios') {
                    xml += generateBachArpeggios(keyNotes, measure);
                } else {
                    xml += generateBachStyle(keyNotes, measure, inst);
                }
            } else if (composer === 'mozart') {
                // Mozart: Elegant classical style
                if (inst === 'guitar' && pattern === 'chords') {
                    xml += generateMozartGuitarChord(keyNotes, measure);
                } else if ((inst === 'violin1' || inst === 'violin2') && pattern === 'melody') {
                    xml += generateMozartMelody(keyNotes, measure, inst);
                } else if (inst === 'cello' && pattern === 'bassline') {
                    xml += generateMozartBassline(keyNotes, measure);
                } else if (inst === 'viola' && pattern === 'arpeggios') {
                    xml += generateMozartArpeggios(keyNotes, measure);
                } else {
                    xml += generateMozartStyle(keyNotes, measure, inst);
                }
            } else if (composer === 'beethoven') {
                // Beethoven: Dramatic romantic style
                if (inst === 'guitar' && pattern === 'chords') {
                    xml += generateBeethovenGuitarChord(keyNotes, measure);
                } else if ((inst === 'violin1' || inst === 'violin2') && pattern === 'melody') {
                    xml += generateBeethovenMelody(keyNotes, measure, inst);
                } else if (inst === 'cello' && pattern === 'bassline') {
                    xml += generateBeethovenBassline(keyNotes, measure);
                } else if (inst === 'viola' && pattern === 'arpeggios') {
                    xml += generateBeethovenArpeggios(keyNotes, measure);
                } else {
                    xml += generateBeethovenStyle(keyNotes, measure, inst);
                }
            } else if (composer === 'jazz') {
                // Jazz: Syncopated modern style
                if (inst === 'guitar' && pattern === 'chords') {
                    xml += generateJazzGuitarChord(keyNotes, measure);
                } else if ((inst === 'violin1' || inst === 'violin2') && pattern === 'melody') {
                    xml += generateJazzMelody(keyNotes, measure, inst);
                } else if (inst === 'cello' && pattern === 'bassline') {
                    xml += generateJazzBassline(keyNotes, measure);
                } else if (inst === 'viola' && pattern === 'arpeggios') {
                    xml += generateJazzArpeggios(keyNotes, measure);
                } else {
                    xml += generateJazzStyle(keyNotes, measure, inst);
                }
            } else {
                // Default style for other composers
                if (inst === 'guitar' && pattern === 'chords') {
                    xml += generateDefaultGuitarChord(keyNotes, measure);
                } else if ((inst === 'violin1' || inst === 'violin2') && pattern === 'melody') {
                    xml += generateDefaultMelody(keyNotes, measure, inst);
                } else if (inst === 'cello' && pattern === 'bassline') {
                    xml += generateDefaultBassline(keyNotes, measure);
                } else if (inst === 'viola' && pattern === 'arpeggios') {
                    xml += generateDefaultArpeggios(keyNotes, measure);
                } else {
                    xml += generateDefaultNotes(keyNotes, measure, inst);
                }
            }
            
            return xml;
        }
        
        // Get composer-specific style characteristics
        function getComposerStyle(composer) {
            const styles = {
                'bach': { rhythm: 'complex', harmony: 'contrapuntal', dynamics: 'moderate' },
                'mozart': { rhythm: 'elegant', harmony: 'classical', dynamics: 'refined' },
                'beethoven': { rhythm: 'dramatic', harmony: 'romantic', dynamics: 'strong' },
                'chopin': { rhythm: 'rubato', harmony: 'romantic', dynamics: 'expressive' },
                'debussy': { rhythm: 'fluid', harmony: 'impressionist', dynamics: 'subtle' },
                'jazz': { rhythm: 'syncopated', harmony: 'extended', dynamics: 'swinging' }
            };
            return styles[composer] || styles['mozart'];
        }
        
        // Get notes in the specified key
        function getKeyNotes(key) {
            const keyMap = {
                'C': ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
                'G': ['G', 'A', 'B', 'C', 'D', 'E', 'F#'],
                'D': ['D', 'E', 'F#', 'G', 'A', 'B', 'C#'],
                'A': ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#'],
                'F': ['F', 'G', 'A', 'Bb', 'C', 'D', 'E'],
                'Bb': ['Bb', 'C', 'D', 'Eb', 'F', 'G', 'A']
            };
            return keyMap[key] || keyMap['C'];
        }
        
        // Generate chord progression based on key and composer
        function getChordProgression(keyNotes, measure, composer) {
            const progressions = {
                'bach': ['I', 'V', 'vi', 'IV', 'I', 'V', 'I'],
                'mozart': ['I', 'IV', 'V', 'I'],
                'beethoven': ['I', 'V', 'I', 'V'],
                'jazz': ['Imaj7', 'V7', 'Imaj7', 'V7'],
                'classical': ['I', 'V', 'I', 'V']
            };
            
            const progression = progressions[composer] || progressions['classical'];
            const chordIndex = (measure - 1) % progression.length;
            return progression[chordIndex];
        }
        
        // Generate guitar chord
        function generateGuitarChord(chord, rhythm) {
            let xml = '';
            if (rhythm === 'complex') {
                // Bach-style complex rhythm - proper chord with chord tags
                xml += '      <note><pitch><step>C</step><octave>3</octave></pitch><duration>2</duration><type>half</type></note>\n';
                xml += '      <note><chord/><pitch><step>E</step><octave>3</octave></pitch><duration>2</duration><type>half</type></note>\n';
                xml += '      <note><chord/><pitch><step>G</step><octave>3</octave></pitch><duration>2</duration><type>half</type></note>\n';
            } else if (rhythm === 'syncopated') {
                // Jazz-style syncopated rhythm - proper chord
                xml += '      <note><pitch><step>C</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n';
                xml += '      <note><chord/><pitch><step>E</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n';
                xml += '      <note><chord/><pitch><step>G</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n';
                xml += '      <note><chord/><pitch><step>Bb</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n';
            } else {
                // Default rhythm - proper chord
                xml += '      <note><pitch><step>C</step><octave>3</octave></pitch><duration>4</duration><type>whole</type></note>\n';
                xml += '      <note><chord/><pitch><step>E</step><octave>3</octave></pitch><duration>4</duration><type>whole</type></note>\n';
                xml += '      <note><chord/><pitch><step>G</step><octave>3</octave></pitch><duration>4</duration><type>whole</type></note>\n';
            }
            return xml;
        }
        
        // Generate Bach-style melody
        function generateBachMelody(keyNotes, measure, inst) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            const octave = inst === 'violin1' ? 5 : 4;
            
            // Bach: Complex contrapuntal rhythm with eighth notes
            // Ensure we don't go out of bounds
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 1) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 2) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>${octave}</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            xml += `      <note><pitch><step>${note2}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note3}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        // Generate Mozart-style melody
        function generateMozartMelody(keyNotes, measure, inst) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const octave = inst === 'violin1' ? 5 : 4;
            
            // Mozart: Elegant quarter and eighth note patterns
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 1) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 2) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note2}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note3}</step><octave>${octave}</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            return xml;
        }
        
        // Generate Beethoven-style melody
        function generateBeethovenMelody(keyNotes, measure, inst) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const octave = inst === 'violin1' ? 5 : 4;
            
            // Beethoven: Dramatic dotted rhythms
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 1) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>${octave}</octave></pitch><duration>3</duration><type>dotted-half</type></note>\n`;
            xml += `      <note><pitch><step>${note2}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        // Generate default melody
        function generateDefaultMelody(keyNotes, measure, inst) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const octave = inst === 'violin1' ? 5 : 4;
            
            // Default: Mix of quarter and half notes
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 1) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>${octave}</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            xml += `      <note><pitch><step>${note2}</step><octave>${octave}</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            return xml;
        }
        
        // Generate Bach-style bassline
        function generateBachBassline(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            
            // Bach: Walking bass with quarter notes
            xml += `      <note><pitch><step>${note}</step><octave>2</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>2</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 2) % keyNotes.length]}</step><octave>2</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 3) % keyNotes.length]}</step><octave>2</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        // Generate jazz-style bassline
        function generateJazzBassline(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            
            xml += `      <note><pitch><step>${note}</step><octave>2</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>2</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 2) % keyNotes.length]}</step><octave>2</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 3) % keyNotes.length]}</step><octave>2</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        // Generate default bassline
        function generateDefaultBassline(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            
            // Default: Half note rhythm
            xml += `      <note><pitch><step>${note}</step><octave>2</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>2</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            return xml;
        }
        
        // Generate Chopin-style arpeggios
        function generateChopinArpeggios(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            
            xml += `      <note><pitch><step>${note}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 2) % keyNotes.length]}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 3) % keyNotes.length]}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        // Generate Debussy-style arpeggios
        function generateDebussyArpeggios(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            
            xml += `      <note><pitch><step>${note}</step><octave>3</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>3</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            return xml;
        }
        
        // Generate default arpeggios
        function generateDefaultArpeggios(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            
            xml += `      <note><pitch><step>${note}</step><octave>3</octave></pitch><duration>4</duration><type>whole</type></note>\n`;
            return xml;
        }
        
        // Generate default notes
        function generateDefaultNotes(keyNotes, measure, inst) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            const octave = inst === 'violin1' ? 5 : inst === 'violin2' ? 4 : inst === 'viola' ? 3 : 2;
            
            xml += `      <note><pitch><step>${note}</step><octave>${octave}</octave></pitch><duration>4</duration><type>whole</type></note>\n`;
            return xml;
        }
        
        // Bach-specific generation functions
        function generateBachGuitarChord(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 2) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 4) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>3</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note2}</step><octave>3</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note3}</step><octave>3</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            return xml;
        }
        
        function generateBachArpeggios(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 1) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 2) % keyNotes.length];
            const note4 = keyNotes[(noteIndex + 3) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note2}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note3}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note4}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        function generateBachStyle(keyNotes, measure, inst) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            const octave = inst === 'violin1' ? 5 : inst === 'violin2' ? 4 : inst === 'viola' ? 3 : 2;
            
            // Bach: Complex contrapuntal style
            xml += `      <note><pitch><step>${note}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 2) % keyNotes.length]}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 3) % keyNotes.length]}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        // Mozart-specific generation functions
        function generateMozartGuitarChord(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 2) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 4) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>3</octave></pitch><duration>4</duration><type>whole</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note2}</step><octave>3</octave></pitch><duration>4</duration><type>whole</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note3}</step><octave>3</octave></pitch><duration>4</duration><type>whole</type></note>\n`;
            return xml;
        }
        
        function generateMozartBassline(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            
            xml += `      <note><pitch><step>${note}</step><octave>2</octave></pitch><duration>4</duration><type>whole</type></note>\n`;
            return xml;
        }
        
        function generateMozartArpeggios(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 1) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>3</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            xml += `      <note><pitch><step>${note2}</step><octave>3</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            return xml;
        }
        
        function generateMozartStyle(keyNotes, measure, inst) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            const octave = inst === 'violin1' ? 5 : inst === 'violin2' ? 4 : inst === 'viola' ? 3 : 2;
            
            // Mozart: Elegant classical style
            xml += `      <note><pitch><step>${note}</step><octave>${octave}</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>${octave}</octave></pitch><duration>2</duration><type>half</type></note>\n`;
            return xml;
        }
        
        // Beethoven-specific generation functions
        function generateBeethovenGuitarChord(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 2) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 4) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>3</octave></pitch><duration>3</duration><type>dotted-half</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note2}</step><octave>3</octave></pitch><duration>3</duration><type>dotted-half</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note3}</step><octave>3</octave></pitch><duration>3</duration><type>dotted-half</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        function generateBeethovenBassline(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            
            xml += `      <note><pitch><step>${note}</step><octave>2</octave></pitch><duration>3</duration><type>dotted-half</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>2</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        function generateBeethovenArpeggios(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 1) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 2) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>3</octave></pitch><duration>3</duration><type>dotted-half</type></note>\n`;
            xml += `      <note><pitch><step>${note2}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        function generateBeethovenStyle(keyNotes, measure, inst) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            const octave = inst === 'violin1' ? 5 : inst === 'violin2' ? 4 : inst === 'viola' ? 3 : 2;
            
            // Beethoven: Dramatic romantic style
            xml += `      <note><pitch><step>${note}</step><octave>${octave}</octave></pitch><duration>3</duration><type>dotted-half</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        // Jazz-specific generation functions
        function generateJazzGuitarChord(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 2) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 4) % keyNotes.length];
            const note4 = keyNotes[(noteIndex + 6) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note2}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note3}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note4}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        function generateJazzMelody(keyNotes, measure, inst) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const octave = inst === 'violin1' ? 5 : 4;
            
            // Jazz: Syncopated melody
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 1) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 2) % keyNotes.length];
            const note4 = keyNotes[(noteIndex + 3) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note2}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note3}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note4}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        function generateJazzArpeggios(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 1) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 2) % keyNotes.length];
            const note4 = keyNotes[(noteIndex + 3) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note2}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note3}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${note4}</step><octave>3</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        function generateJazzStyle(keyNotes, measure, inst) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note = keyNotes[noteIndex];
            const octave = inst === 'violin1' ? 5 : inst === 'violin2' ? 4 : inst === 'viola' ? 3 : 2;
            
            // Jazz: Syncopated modern style
            xml += `      <note><pitch><step>${note}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 1) % keyNotes.length]}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 2) % keyNotes.length]}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            xml += `      <note><pitch><step>${keyNotes[(noteIndex + 3) % keyNotes.length]}</step><octave>${octave}</octave></pitch><duration>1</duration><type>quarter</type></note>\n`;
            return xml;
        }
        
        // Default generation functions
        function generateDefaultGuitarChord(keyNotes, measure) {
            let xml = '';
            const noteIndex = (measure - 1) % keyNotes.length;
            const note1 = keyNotes[noteIndex];
            const note2 = keyNotes[(noteIndex + 2) % keyNotes.length];
            const note3 = keyNotes[(noteIndex + 4) % keyNotes.length];
            
            xml += `      <note><pitch><step>${note1}</step><octave>3</octave></pitch><duration>4</duration><type>whole</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note2}</step><octave>3</octave></pitch><duration>4</duration><type>whole</type></note>\n`;
            xml += `      <note><chord/><pitch><step>${note3}</step><octave>3</octave></pitch><duration>4</duration><type>whole</type></note>\n`;
            return xml;
        }
        
        // Reset all
        function resetAll() {
            sections = [];
            currentScore = null;
            sectionCounter = 0;
            document.getElementById('exportBtn').disabled = true;
            document.getElementById('sectionsContainer').innerHTML = '';
            showStatus('Reset complete', 'info');
        }
        
        // Show status
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status-${type}`;
            
            setTimeout(() => {
                status.textContent = '';
                status.className = '';
            }, 3000);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            showStatus('Ready to compose!', 'success');
        });
    </script>
</body>
</html>
