<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Quintet Composer v57 - SIBELIUS FIX</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .version {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
            font-size: 0.95em;
        }
        input, select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 10px 5px;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .button-group {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .output {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            max-height: 400px;
            overflow-y: auto;
        }
        .status {
            text-align: center;
            margin: 20px 0;
            font-size: 1.1em;
        }
        .status.generating { color: #f39c12; }
        .status.complete { color: #27ae60; }
        .status.error { color: #e74c3c; }
        .debug-info {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéº String Quintet Composer</h1>
        <div class="version">Version 57 - SIBELIUS FIX + TRIPLE/QUAD STOPS</div>
        
        <div class="controls">
            <div class="control-group">
                <label for="measures">Number of Measures:</label>
                <input type="number" id="measures" min="8" max="64" value="16">
            </div>
            
            <div class="control-group">
                <label for="tempo">Tempo (BPM):</label>
                <input type="number" id="tempo" min="40" max="200" value="120">
            </div>
            
            <div class="control-group">
                <label for="key">Key:</label>
                <select id="key">
                    <option value="C">C Major</option>
                    <option value="G">G Major</option>
                    <option value="D" selected>D Major</option>
                    <option value="A">A Major</option>
                    <option value="F">F Major</option>
                    <option value="Bb">B‚ô≠ Major</option>
                    <option value="Am">A Minor</option>
                    <option value="Em">E Minor</option>
                    <option value="Dm">D Minor</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="style">Compositional Style:</label>
                <select id="style">
                    <option value="classical">Classical (Haydn/Mozart)</option>
                    <option value="romantic">Romantic (Brahms/Schumann)</option>
                    <option value="modern">Modern (Bart√≥k/Shostakovich)</option>
                    <option value="minimalist">Minimalist (Glass/Reich)</option>
                    <option value="folk">Folk-Inspired</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="guitarStyle">Guitar Style:</label>
                <select id="guitarStyle">
                    <option value="arpeggiated">Arpeggiated</option>
                    <option value="strummed">Strummed Chords</option>
                    <option value="fingerstyle">Fingerstyle</option>
                    <option value="classical">Classical Pattern</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="multipleStops">Multiple Stops Density:</label>
                <select id="multipleStops">
                    <option value="none">None (0%)</option>
                    <option value="low">Low (20%)</option>
                    <option value="medium" selected>Medium (40%)</option>
                    <option value="high">High (60%)</option>
                </select>
            </div>
        </div>
        
        <div class="button-group">
            <button onclick="generateComposition()">üéµ Generate Composition</button>
            <button onclick="playComposition()" id="playBtn" disabled>‚ñ∂Ô∏è Play Audio</button>
            <button onclick="stopPlayback()" id="stopBtn" disabled>‚èπÔ∏è Stop</button>
            <button onclick="exportMusicXML()" id="exportBtn" disabled>üìÑ Export MusicXML</button>
        </div>
        
        <div class="status" id="status"></div>
        <div class="output" id="output"></div>
        <div class="debug-info" id="debug"></div>
    </div>

    <script>
        let composition = null;
        let audioContext = null;
        let currentNotes = [];
        let isPlaying = false;
        let stopRequested = false;

        const scales = {
            'C': { notes: [60, 62, 64, 65, 67, 69, 71], tonic: 60 },
            'G': { notes: [55, 57, 59, 60, 62, 64, 66], tonic: 55 },
            'D': { notes: [50, 52, 54, 55, 57, 59, 61], tonic: 50 },
            'A': { notes: [57, 59, 61, 62, 64, 66, 68], tonic: 57 },
            'F': { notes: [53, 55, 57, 58, 60, 62, 64], tonic: 53 },
            'Bb': { notes: [58, 60, 62, 63, 65, 67, 69], tonic: 58 },
            'Am': { notes: [57, 59, 60, 62, 64, 65, 67], tonic: 57 },
            'Em': { notes: [52, 54, 55, 57, 59, 60, 62], tonic: 52 },
            'Dm': { notes: [50, 52, 53, 55, 57, 58, 60], tonic: 50 }
        };

        const instrumentRanges = {
            guitar: { min: 40, max: 67, name: 'Guitar', clef: 'treble' },
            violin1: { min: 55, max: 103, name: 'Violin I', clef: 'treble' },
            violin2: { min: 55, max: 96, name: 'Violin II', clef: 'treble' },
            viola: { min: 48, max: 84, name: 'Viola', clef: 'alto' },
            cello: { min: 36, max: 76, name: 'Cello', clef: 'bass' }
        };

        function generateComposition() {
            try {
                const measures = parseInt(document.getElementById('measures').value);
                const tempo = parseInt(document.getElementById('tempo').value);
                const key = document.getElementById('key').value;
                const style = document.getElementById('style').value;
                const guitarStyle = document.getElementById('guitarStyle').value;
                const multipleStops = document.getElementById('multipleStops').value;
                
                document.getElementById('status').className = 'status generating';
                document.getElementById('status').textContent = 'Generating composition...';
                document.getElementById('debug').innerHTML = '';
                document.getElementById('debug').style.display = 'block';
                
                composition = {
                    tempo: tempo,
                    timeSignature: '4/4',
                    key: key,
                    measures: measures,
                    parts: {}
                };

                const keyData = scales[key];
                const progressions = getProgressions(style);
                
                // Generate parts
                ['guitar', 'violin1', 'violin2', 'viola', 'cello'].forEach(instrument => {
                    composition.parts[instrument] = generatePart(
                        instrument, measures, keyData, progressions, 
                        guitarStyle, style, multipleStops
                    );
                });

                document.getElementById('playBtn').disabled = false;
                document.getElementById('exportBtn').disabled = false;
                document.getElementById('status').className = 'status complete';
                document.getElementById('status').textContent = 'Composition generated successfully!';
                
                displayComposition();
                
            } catch (error) {
                console.error('Generation error:', error);
                document.getElementById('status').className = 'status error';
                document.getElementById('status').textContent = 'Error: ' + error.message;
            }
        }

        function getProgressions(style) {
            const progressions = {
                'classical': [[1, 4, 5, 1], [1, 5, 1, 4, 5, 1]],
                'romantic': [[1, 6, 4, 5], [1, 2, 5, 1], [1, 4, 2, 5, 1]],
                'modern': [[1, 3, 7, 1], [1, 2, 4, 5], [1, 5, 3, 6, 1]],
                'minimalist': [[1, 1, 1, 1], [1, 5, 1, 5]],
                'folk': [[1, 4, 1, 5], [1, 5, 6, 5, 1]]
            };
            return progressions[style] || progressions['classical'];
        }

        function generatePart(instrument, measures, keyData, progressions, guitarStyle, style, multipleStops) {
            const part = [];
            let totalMultipleStops = 0;
            const stopDensity = {
                'none': 0,
                'low': 0.2,
                'medium': 0.4,
                'high': 0.6
            }[multipleStops];

            for (let m = 0; m < measures; m++) {
                const progression = progressions[m % progressions.length];
                const degree = progression[m % progression.length];
                const chord = generateChord(keyData, degree);
                
                let measure;
                if (instrument === 'guitar') {
                    measure = generateGuitarPart(chord, guitarStyle);
                } else if (instrument === 'violin1') {
                    measure = generateMelody(chord, keyData);
                } else {
                    measure = generateHarmony(chord, instrument);
                }

                // Add multiple stops for string instruments
                if (instrument !== 'guitar' && stopDensity > 0) {
                    measure = addMultipleStops(measure, instrument, stopDensity);
                    // Count multiple stops
                    measure.forEach(event => {
                        if (event.notes && event.notes.length > 1) {
                            totalMultipleStops++;
                        }
                    });
                }

                part.push(measure);
            }

            // Debug output
            if (instrument !== 'guitar' && stopDensity > 0) {
                addDebug(`${instrument}: Generated ${totalMultipleStops} multiple stops`);
            }

            return part;
        }

        function generateChord(keyData, degree) {
            // Fixed chord generation - proper array indexing
            const root = keyData.notes[(degree - 1) % 7];
            const third = keyData.notes[(degree + 1) % 7];
            const fifth = keyData.notes[(degree + 3) % 7];
            return [root, third, fifth];
        }

        function generateGuitarPart(chord, style) {
            const events = [];
            
            if (style === 'strummed') {
                // Full chord strums
                for (let beat = 0; beat < 4; beat++) {
                    const notes = [];
                    // Build 6-note guitar chord
                    notes.push(chord[0] - 12); // Root an octave down
                    notes.push(chord[2] - 5);  // Fifth
                    notes.push(chord[0]);      // Root
                    notes.push(chord[1]);      // Third
                    notes.push(chord[2]);      // Fifth
                    notes.push(chord[0] + 12); // Root octave up
                    
                    // Filter to guitar range
                    const filtered = notes.filter(n => n >= 40 && n <= 67);
                    
                    events.push({
                        notes: filtered,
                        duration: 1,
                        isChord: true
                    });
                }
            } else if (style === 'fingerstyle') {
                // Travis picking pattern
                events.push({ notes: [chord[0] - 12].filter(n => n >= 40), duration: 0.5 });
                events.push({ notes: [chord[1], chord[2]].filter(n => n <= 67), duration: 0.5, isChord: true });
                events.push({ notes: [chord[2] - 12].filter(n => n >= 40), duration: 0.5 });
                events.push({ notes: [chord[0], chord[1]].filter(n => n <= 67), duration: 0.5, isChord: true });
            } else if (style === 'classical') {
                // Block chord
                const classicalChord = [chord[0] - 12, chord[2] - 5, chord[0], chord[1]]
                    .filter(n => n >= 40 && n <= 67);
                events.push({ notes: classicalChord, duration: 4, isChord: true });
            } else {
                // Arpeggiated
                const arp = [chord[0] - 12, chord[2] - 5, chord[0], chord[1], chord[2], chord[0] + 12]
                    .filter(n => n >= 40 && n <= 67);
                arp.forEach((note, i) => {
                    events.push({ notes: [note], duration: 0.666 });
                });
            }
            
            return events;
        }

        function generateMelody(chord, keyData) {
            const events = [];
            const rhythms = [1, 1, 0.5, 0.5, 1];
            
            for (let i = 0; i < rhythms.length && i < 4; i++) {
                const useChordTone = Math.random() < 0.8;
                let note;
                
                if (useChordTone) {
                    note = chord[Math.floor(Math.random() * chord.length)] + 24;
                } else {
                    note = keyData.notes[Math.floor(Math.random() * keyData.notes.length)] + 24;
                }
                
                // Keep in violin range
                while (note < 67) note += 12;
                while (note > 96) note -= 12;
                
                events.push({ notes: [note], duration: rhythms[i] });
            }
            
            return events;
        }

        function generateHarmony(chord, instrument) {
            const events = [];
            const range = instrumentRanges[instrument];
            
            // Simple whole note for harmony parts
            let note = chord[Math.floor(Math.random() * chord.length)];
            
            // Adjust octave for instrument range
            if (instrument === 'violin2') {
                note += 12;
                while (note < 67 || note > 84) {
                    if (note < 67) note += 12;
                    if (note > 84) note -= 12;
                }
            } else if (instrument === 'viola') {
                while (note < 48 || note > 72) {
                    if (note < 48) note += 12;
                    if (note > 72) note -= 12;
                }
            } else if (instrument === 'cello') {
                note -= 12;
                while (note < 36 || note > 60) {
                    if (note < 36) note += 12;
                    if (note > 60) note -= 12;
                }
            }
            
            events.push({ notes: [note], duration: 4 });
            return events;
        }

        function addMultipleStops(measure, instrument, density) {
            const enhanced = [];
            
            measure.forEach((event, index) => {
                if (Math.random() < density && event.notes && event.notes.length === 1) {
                    const baseNote = event.notes[0];
                    const newNotes = [baseNote];
                    
                    // Add additional notes based on instrument
                    if (instrument === 'violin1' || instrument === 'violin2') {
                        // Double stops - add a third, fourth, fifth, or sixth
                        const intervals = [3, 4, 5, 7, 8];
                        const interval = intervals[Math.floor(Math.random() * intervals.length)];
                        const secondNote = baseNote + interval;
                        
                        if (secondNote <= instrumentRanges[instrument].max) {
                            newNotes.push(secondNote);
                        }
                        
                        // Occasionally add triple stop for violins (rare)
                        if (Math.random() < 0.1 && instrument === 'violin1') {
                            const thirdNote = baseNote - 5;
                            if (thirdNote >= instrumentRanges[instrument].min) {
                                newNotes.push(thirdNote);
                            }
                        }
                    } else if (instrument === 'viola') {
                        // Viola can do double and triple stops
                        const intervals = [3, 5, 7, 12];
                        const interval = intervals[Math.floor(Math.random() * intervals.length)];
                        const secondNote = baseNote + interval;
                        
                        if (secondNote <= instrumentRanges[instrument].max) {
                            newNotes.push(secondNote);
                        }
                        
                        // Triple stops for viola
                        if (Math.random() < 0.3) {
                            const thirdNote = baseNote - 7;
                            if (thirdNote >= instrumentRanges[instrument].min) {
                                newNotes.push(thirdNote);
                            }
                        }
                    } else if (instrument === 'cello') {
                        // Cello can do double, triple, and even quadruple stops
                        const intervals = [5, 7, 12];
                        const interval = intervals[Math.floor(Math.random() * intervals.length)];
                        const secondNote = baseNote + interval;
                        
                        if (secondNote <= instrumentRanges[instrument].max) {
                            newNotes.push(secondNote);
                        }
                        
                        // Triple stops for cello
                        if (Math.random() < 0.4) {
                            const thirdNote = baseNote + 19; // Octave + fifth
                            if (thirdNote <= instrumentRanges[instrument].max) {
                                newNotes.push(thirdNote);
                            }
                        }
                        
                        // Quadruple stops for cello (rare, forte passages)
                        if (Math.random() < 0.05) {
                            const fourthNote = baseNote + 24; // Two octaves
                            if (fourthNote <= instrumentRanges[instrument].max) {
                                newNotes.push(fourthNote);
                            }
                        }
                    }
                    
                    enhanced.push({
                        notes: newNotes,
                        duration: event.duration,
                        isMultipleStop: newNotes.length > 1
                    });
                } else {
                    enhanced.push(event);
                }
            });
            
            return enhanced;
        }

        function displayComposition() {
            let output = '<h3>Composition Structure</h3>';
            output += `<p>Tempo: ${composition.tempo} BPM | Key: ${composition.key} | Measures: ${composition.measures}</p>`;
            
            let multipleStopsCount = { total: 0, double: 0, triple: 0, quad: 0 };
            
            Object.keys(composition.parts).forEach(instrument => {
                const part = composition.parts[instrument];
                let noteCount = 0;
                let chordCount = 0;
                
                part.forEach(measure => {
                    measure.forEach(event => {
                        if (event.notes) {
                            if (event.notes.length === 1) {
                                noteCount++;
                            } else if (event.notes.length === 2) {
                                multipleStopsCount.double++;
                                multipleStopsCount.total++;
                            } else if (event.notes.length === 3) {
                                multipleStopsCount.triple++;
                                multipleStopsCount.total++;
                            } else if (event.notes.length >= 4) {
                                multipleStopsCount.quad++;
                                multipleStopsCount.total++;
                                chordCount++;
                            }
                        }
                    });
                });
                
                output += `<p><strong>${instrumentRanges[instrument].name}:</strong> `;
                output += `${noteCount} notes`;
                if (chordCount > 0) output += `, ${chordCount} chords`;
                output += '</p>';
            });
            
            output += `<h4>Multiple Stops Statistics:</h4>`;
            output += `<p>Total: ${multipleStopsCount.total} | `;
            output += `Double: ${multipleStopsCount.double} | `;
            output += `Triple: ${multipleStopsCount.triple} | `;
            output += `Quadruple: ${multipleStopsCount.quad}</p>`;
            
            document.getElementById('output').innerHTML = output;
        }

        function addDebug(message) {
            const debug = document.getElementById('debug');
            debug.innerHTML += message + '<br>';
        }

        async function playComposition() {
            if (!composition) return;
            
            stopRequested = false;
            isPlaying = true;
            document.getElementById('playBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const tempo = composition.tempo;
            const beatDuration = 60 / tempo;
            
            for (let measure = 0; measure < composition.measures && !stopRequested; measure++) {
                for (let instrument in composition.parts) {
                    if (stopRequested) break;
                    
                    const events = composition.parts[instrument][measure];
                    let beatPosition = 0;
                    
                    for (let event of events) {
                        if (stopRequested) break;
                        
                        if (event.notes && event.notes.length > 0) {
                            const startTime = audioContext.currentTime + (beatPosition * beatDuration);
                            
                            event.notes.forEach((note, index) => {
                                playNote(note, startTime, event.duration * beatDuration, instrument, index > 0);
                            });
                        }
                        
                        beatPosition += event.duration;
                    }
                }
                
                if (!stopRequested) {
                    await new Promise(resolve => setTimeout(resolve, 4 * beatDuration * 1000));
                }
            }
            
            isPlaying = false;
            document.getElementById('playBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        function playNote(midiNote, startTime, duration, instrument, isMultipleStop = false) {
            const freq = 440 * Math.pow(2, (midiNote - 69) / 12);
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.frequency.value = freq;
            
            // Different timbres for instruments
            if (instrument === 'guitar') {
                oscillator.type = 'triangle';
                gainNode.gain.value = 0.15;
            } else if (instrument.includes('violin')) {
                oscillator.type = 'sawtooth';
                gainNode.gain.value = isMultipleStop ? 0.12 : 0.18;
            } else if (instrument === 'viola') {
                oscillator.type = 'sawtooth';
                gainNode.gain.value = isMultipleStop ? 0.14 : 0.20;
            } else if (instrument === 'cello') {
                oscillator.type = 'sawtooth';
                gainNode.gain.value = isMultipleStop ? 0.18 : 0.25;
            }
            
            // Add slight detuning for multiple stops
            if (isMultipleStop) {
                oscillator.detune.value = (Math.random() - 0.5) * 10;
            }
            
            // ADSR envelope
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(gainNode.gain.value, startTime + 0.02);
            gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
        }

        function stopPlayback() {
            stopRequested = true;
            isPlaying = false;
            document.getElementById('playBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        function exportMusicXML() {
            if (!composition) return;
            
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">\n';
            xml += '<score-partwise version="3.1">\n';
            xml += '  <identification>\n';
            xml += '    <creator type="composer">String Quintet Composer v57</creator>\n';
            xml += '  </identification>\n';
            xml += '  <part-list>\n';
            
            const instruments = ['guitar', 'violin1', 'violin2', 'viola', 'cello'];
            instruments.forEach((inst, index) => {
                xml += `    <score-part id="P${index + 1}">\n`;
                xml += `      <part-name>${instrumentRanges[inst].name}</part-name>\n`;
                if (inst === 'guitar') {
                    xml += '      <score-instrument id="P1-I1">\n';
                    xml += '        <instrument-name>Classical Guitar</instrument-name>\n';
                    xml += '      </score-instrument>\n';
                }
                xml += '    </score-part>\n';
            });
            
            xml += '  </part-list>\n';
            
            // Generate parts
            instruments.forEach((instrument, partIndex) => {
                xml += `  <part id="P${partIndex + 1}">\n`;
                
                // First measure includes attributes
                xml += '    <measure number="1">\n';
                xml += '      <attributes>\n';
                xml += '        <divisions>4</divisions>\n';
                xml += `        <key><fifths>${getKeySignature(composition.key)}</fifths></key>\n`;
                xml += '        <time><beats>4</beats><beat-type>4</beat-type></time>\n';
                
                // Set clef
                const clef = instrumentRanges[instrument].clef;
                if (clef === 'treble') {
                    xml += '        <clef><sign>G</sign><line>2</line></clef>\n';
                    if (instrument === 'guitar') {
                        xml += '        <transpose>\n';
                        xml += '          <diatonic>0</diatonic>\n';
                        xml += '          <chromatic>0</chromatic>\n';
                        xml += '          <octave-change>-1</octave-change>\n';
                        xml += '        </transpose>\n';
                    }
                } else if (clef === 'alto') {
                    xml += '        <clef><sign>C</sign><line>3</line></clef>\n';
                } else if (clef === 'bass') {
                    xml += '        <clef><sign>F</sign><line>4</line></clef>\n';
                }
                
                xml += '      </attributes>\n';
                
                // Add tempo to first measure of first part
                if (partIndex === 0) {
                    xml += '      <direction placement="above">\n';
                    xml += '        <direction-type>\n';
                    xml += `          <metronome><beat-unit>quarter</beat-unit><per-minute>${composition.tempo}</per-minute></metronome>\n`;
                    xml += '        </direction-type>\n';
                    xml += '      </direction>\n';
                }
                
                // Process first measure
                const events = composition.parts[instrument][0];
                xml += processEvents(events, instrument);
                xml += '    </measure>\n';
                
                // Process remaining measures
                for (let m = 1; m < composition.measures; m++) {
                    xml += `    <measure number="${m + 1}">\n`;
                    const events = composition.parts[instrument][m];
                    xml += processEvents(events, instrument);
                    xml += '    </measure>\n';
                }
                
                xml += '  </part>\n';
            });
            
            xml += '</score-partwise>';
            
            downloadXML(xml);
        }

        function processEvents(events, instrument) {
            let xml = '';
            
            events.forEach((event, eventIndex) => {
                if (event.notes && event.notes.length > 0) {
                    event.notes.forEach((note, noteIndex) => {
                        xml += '      <note>\n';
                        
                        // Mark additional notes in chord
                        if (noteIndex > 0) {
                            xml += '        <chord/>\n';
                        }
                        
                        // Calculate pitch
                        let displayNote = note;
                        if (instrument === 'guitar') {
                            displayNote = note + 12; // Write guitar an octave higher
                        }
                        
                        const pitchInfo = midiToPitch(displayNote);
                        xml += '        <pitch>\n';
                        xml += `          <step>${pitchInfo.step}</step>\n`;
                        if (pitchInfo.alter !== 0) {
                            xml += `          <alter>${pitchInfo.alter}</alter>\n`;
                        }
                        xml += `          <octave>${pitchInfo.octave}</octave>\n`;
                        xml += '        </pitch>\n';
                        
                        // Duration
                        xml += `        <duration>${Math.floor(event.duration * 4)}</duration>\n`;
                        
                        // Note type
                        const noteType = getNoteType(event.duration);
                        xml += `        <type>${noteType}</type>\n`;
                        
                        xml += '      </note>\n';
                    });
                }
            });
            
            return xml;
        }

        function midiToPitch(midiNote) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(midiNote / 12) - 1;
            const noteIndex = midiNote % 12;
            const noteName = noteNames[noteIndex];
            
            let step = noteName[0];
            let alter = 0;
            if (noteName.includes('#')) {
                alter = 1;
                step = noteName[0];
            }
            
            return { step: step, alter: alter, octave: octave };
        }

        function getNoteType(duration) {
            if (duration >= 4) return 'whole';
            if (duration >= 2) return 'half';
            if (duration >= 1) return 'quarter';
            if (duration >= 0.5) return 'eighth';
            return 'sixteenth';
        }

        function getKeySignature(key) {
            const signatures = {
                'C': 0, 'G': 1, 'D': 2, 'A': 3, 'F': -1, 'Bb': -2,
                'Am': 0, 'Em': 1, 'Dm': -1
            };
            return signatures[key] || 0;
        }

        function downloadXML(content) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `quintet_composition_${timestamp}.musicxml`;
            
            const blob = new Blob([content], { type: 'application/vnd.recordare.musicxml+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>